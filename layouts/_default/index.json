[{"contents":"The additionalProperties keyword is used to control the handling of properties whose names are not listed in the properties keyword or match any of the regular expressions in the patternProperties keyword. By default any additional properties are allowed.\nThe behavior of this keyword depends on the presence and annotation results of properties and patternProperties within the same schema object. Validation with additionalProperties applies only to the child values of instance names that do not appear in the annotation results of either properties or patternProperties.\nExamples Schema with \u0026#39;additionalProperties\u0026#39; set to boolean false\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;additionalProperties\u0026#34;: false } Valid\rAn instance with no additional properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Invalid\rAn instance with additional properties is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } When additionalProperties is set to false, all the instance properties must either be present in the properties or match any regex within patternProperties; otherwise, the validaion will fail. Schema with \u0026#39;additionalProperties\u0026#39; set to an object schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;additionalProperties\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 21 } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34; ] }, { \u0026#34;keyword\u0026#34;: \u0026#34;/additionalProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;age\u0026#34; ] } Invalid\rThe value of \u0026#39;age\u0026#39; must be a number\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;21\u0026#34; } The value of additionalProperties can either be a boolean schema or an object schema. Schema with \u0026#39;patternProperties\u0026#39;, \u0026#39;properties\u0026#39; and \u0026#39;additionalProperties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;additionalProperties\u0026#34;: true } Invalid\rThe value of the \u0026#39;name\u0026#39; property must be a string\rInstance\r{ \u0026#34;name\u0026#34;: [ \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34; ], \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;Age\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/additionalProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;email\u0026#34; ] } Instance properties (keys) not present in properties or not matching any regex within patternProperties are evaluated against additionalProperties. Schema with no \u0026#39;additionalProperties\u0026#39; defined\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Invalid\rThe value of \u0026#39;Age\u0026#39; must be a number\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: \u0026#34;21\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Valid\rAn object instance with additional properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;com\u0026#34; ] } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;Age\u0026#34; ] } Note: JSON Schema is a constraint language and if you don\u0026rsquo;t limit keywords like this, then more keywords than what you defined in properties, etc would be allowed. If you don\u0026rsquo;t define a property using properties or patternProperties, but don\u0026rsquo;t disallow it with additionalProperties, it would still be valid with any value.\n","permalink":"http://localhost:1313/2020-12/applicator/additionalproperties/","tags":["applicator","annotation"],"title":"additionalProperties"},{"contents":"The allOf keyword is used to specify that a given instance must validate against all of the subschemas provided within an array. It\u0026rsquo;s essentially a logical \u0026ldquo;AND\u0026rdquo; operation where all conditions must be met for validation to pass.\nExamples Schema with \u0026#39;allOf\u0026#39; keyword containing only one subschema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;allOf\u0026#34;: [ { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Valid\rAn instance conforming to all the subschemas of \u0026#39;allOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rThe value of \u0026#39;foo\u0026#39; must be a string\rInstance\r{ \u0026#34;foo\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Schema with \u0026#39;allOf\u0026#39; keyword containing multiple subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;allOf\u0026#34;: [ { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] }, { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;bar\u0026#34; ] } ] } Valid\rAn instance conforming to all the subschemas of \u0026#39;allOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 33 } Invalid\rAn instance that does not conform to both subschemas within \u0026#39;allOf\u0026#39; is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Schema with \u0026#39;allOf\u0026#39; keyword containing some boolean subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;allOf\u0026#34;: [ true, { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Valid\rAn instance conforming to all the subschemas of \u0026#39;allOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rThe value of \u0026#39;foo\u0026#39; must be a string\rInstance\r{ \u0026#34;foo\u0026#34;: true } Schema with \u0026#39;allOf\u0026#39; keyword containing some boolean subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;allOf\u0026#34;: [ false, { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Invalid\rAn instance not conforming to the second subschema of \u0026#39;allOf\u0026#39; is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: false } Invalid\rAn instance conforming to the second subschema of \u0026#39;allOf\u0026#39; is also invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Remember, if any subschema within the allOf keyword fails validation or has a boolean false value, the entire validation will always fail. Schema with nested \u0026#39;allOf\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;allOf\u0026#34;: [ { \u0026#34;allOf\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } ] }, { \u0026#34;allOf\u0026#34;: [ { \u0026#34;minimum\u0026#34;: 18 } ] } ] } Valid\rAn instance conforming to all the subschemas including the nested \u0026#39;allOf\u0026#39; is valid\rInstance\r25 Invalid\rThe validation fails due to the 2nd subschema of the top-level \u0026#39;allOf\u0026#39;\rInstance\r10 ","permalink":"http://localhost:1313/2020-12/applicator/allof/","tags":["applicator"],"title":"allOf"},{"contents":"The anyOf keyword in JSON Schema is used to specify that an instance must validate against at least one of the schemas provided in an array. It allows you to define multiple schemas, and if the data validates against any one of them, the validation passes.\nExamples Schema with \u0026#39;anyOf\u0026#39; keyword containing only one subschema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;anyOf\u0026#34;: [ { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Valid\rAn instance conforming to at least one subschemas of \u0026#39;anyOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rThe value of \u0026#39;foo\u0026#39; must be a string\rInstance\r{ \u0026#34;foo\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Schema with \u0026#39;anyOf\u0026#39; keyword containing multiple subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;anyOf\u0026#34;: [ { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] }, { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;bar\u0026#34; ] } ] } Valid\rAn instance conforming to at least one of the subschemas of \u0026#39;anyOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rAn instance that does not conform to any of the subschemas of \u0026#39;anyOf\u0026#39; is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: 33, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Valid\rAn instance conforming to all the subschemas of \u0026#39;anyOf\u0026#39; is also valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 33 } Schema with \u0026#39;anyOf\u0026#39; keyword containing some boolean subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;anyOf\u0026#34;: [ false, { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Valid\rAn instance conforming to the second subschema of \u0026#39;anyOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rAn instance not conforming to the second subschema of \u0026#39;anyOf\u0026#39; is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: false } Schema with \u0026#39;anyOf\u0026#39; keyword containing some boolean subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;anyOf\u0026#34;: [ true, { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Valid\rAn instance conforming to all the subschemas of \u0026#39;anyOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Valid\rAn instance not conforming to the second subschema of \u0026#39;anyOf\u0026#39; is also valid\rInstance\r{ \u0026#34;foo\u0026#34;: true } Remember, if any subschema within the anyOf keyword passes validation or has a boolean true value, the overall result of anyOf is considered valid. Schema with nested \u0026#39;anyOf\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;anyOf\u0026#34;: [ { \u0026#34;anyOf\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } ] }, { \u0026#34;anyOf\u0026#34;: [ { \u0026#34;minimum\u0026#34;: 18 } ] } ] } Valid\rAn instance conforming to all the subschemas including the nested \u0026#39;anyOf\u0026#39; is valid\rInstance\r25 Valid\rAn instance not conforming to the second subschema of top-level \u0026#39;anyOf\u0026#39; is also valid\rInstance\r10 For the first instance above, validation passes against the first subschema within anyOf, thereby making the anyOf keyword valid, regardless of the validation result against the second subschema.\nSimilarly, for the second instance above, validation passes against the first subschema within anyOf. Even though the instance does not conform to the second subschema, validation does not proceed to validate against it, as it has already been successfully validated against the first subschema. Thus, the validation stops at that point, rendering the anyOf valid, despite the instance not conforming to the second subschema within the anyOf.\nCommon Pitfall\rImportant note on performance and annotations:\nWhen running validation only, a JSON Schema implementation may stop validating anyOf when it encounters a successful one. However, when collecting annotations, it must evaluate all of them. The process of collecting annotations can impact runtime performance. For instance, if you collect annotations on a JSON Schema utilizing the anyOf applicator, the implementation is forced to evaluate the instance against every disjunction in the anyOf applicator. Conversely, if annotations are not collected, implementations may stop evaluation as soon as one anyOf subschema successfully validates against the instance. In the interest of runtime efficiency, we recommend collecting annotations only if your specific use case demands it. ","permalink":"http://localhost:1313/2020-12/applicator/anyof/","tags":["applicator"],"title":"anyOf"},{"contents":"The contains keyword is used to check if at least one element in an array instance validates against a specified sub-schema. It offers flexibility compared to items, which requires all elements to adhere to a single schema.\nAn array instance is valid against contains if at least one of its elements is valid against the given schema, except when minContains is present and has a value of 0, in which case an array instance must be considered valid against the contains keyword, even if none of its elements is valid against the given schema.\nSimilarly, if maxContains is present alongside contains, the instance will be considered valid as long as the number of elements successfully validating against the contains subschema does not exceed the specified limit defined by maxContains.\nFor data validation, items validates all array elements against a single schema, prefixItems validates a fixed-length sequence at the array\u0026rsquo;s beginning, and contains checks for at least one element matching a schema anywhere in the array. The subschema must be applied to every array element, even after the first match has been found, to collect annotations for use by other keywords. Examples Schema with \u0026#39;contains\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Valid\rAn array instance with at least one item as a numeric value is valid\rInstance\r[ \u0026#34;foo\u0026#34;, 3, false, [ \u0026#34;bar\u0026#34; ], -5 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/contains\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ 1, 4 ] } Invalid\rAn array instance containing no string value is invalid\rInstance\r[ \u0026#34;foo\u0026#34;, true ] Schema with \u0026#39;contains\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } Valid\rAn array instance with all items as string values is valid\rInstance\r[ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34; ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/contains\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } The annotation value is a boolean \u0026rsquo;true\u0026rsquo; if the subschema successfully validates when applied to every index of the instance. ","permalink":"http://localhost:1313/2020-12/applicator/contains/","tags":["applicator","annotation"],"title":"contains"},{"contents":"The dependentSchemas keyword allows you to define dependencies between properties based on the presence of other properties within an instance. It extends the functionality of the dependentRequired keyword by allowing you to pass in a full schema. The instance will be considered valid only if the dependent properties adhere to the dependentSchemas schema.\nEach key in the object represents a property name. Instance is valid if the associated property is present and conforms to the subschema. Examples Schema with the \u0026#39;dependentSchemas\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;license\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;dependentSchemas\u0026#34;: { \u0026#34;license\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;age\u0026#34; ] } } } Valid\rAn instance with both \u0026#39;age\u0026#39; and \u0026#39;license\u0026#39; properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;license\u0026#34;: \u0026#34;XYZ123\u0026#34; } Invalid\rAn instance with the \u0026#39;age\u0026#39; property not conforming to the subschema is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;XYZ123\u0026#34; } Valid\rWhen the \u0026#39;license\u0026#39; property is missing, the \u0026#39;age\u0026#39; property will not affect the validation\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;25\u0026#34; } Invalid\rAn instance with missing \u0026#39;age\u0026#39; property when \u0026#39;license\u0026#39; property is present is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;XYZ123\u0026#34; } Complex schema with the \u0026#39;dependentSchemas\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;dependentSchemas\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;dependentSchemas\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;eligible\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;eligible\u0026#34; ] } }, \u0026#34;required\u0026#34;: [ \u0026#34;age\u0026#34; ] } } } Valid\rAn instance with all the required properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 15, \u0026#34;eligible\u0026#34;: false } Invalid\rAn instance with \u0026#39;age\u0026#39; property not conforming to the schema is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;manager\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;eligible\u0026#34;: true } Valid\r\u0026#39;age\u0026#39; and \u0026#39;eligible\u0026#39; properties do not affect the validation when the \u0026#39;name\u0026#39; property is missing\rInstance\r{ \u0026#34;age\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;eligible\u0026#34;: true } Valid\r\u0026#39;age\u0026#39; and \u0026#39;eligible\u0026#39; properties do not affect the validation when the \u0026#39;name\u0026#39; property is missing\rInstance\r{ \u0026#34;age\u0026#34;: \u0026#34;25\u0026#34;, \u0026#34;eligible\u0026#34;: true } Invalid\rAn instance with missing \u0026#39;eligible\u0026#39; property when \u0026#39;age\u0026#39; property is present is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;manager\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;25\u0026#34; } ","permalink":"http://localhost:1313/2020-12/applicator/dependentschemas/","tags":["applicator"],"title":"dependentSchemas"},{"contents":"The else keyword is used in conjunction with if to define a schema to be applied when a condition specified in the if keyword is false. It allows you to define alternative validation rules for instances that do not satisfy the conditions specified in the if keyword.\nThis keyword has no effect when if is absent. This keyword has no effect when the instance passes validation against the if subschema. Examples Schema with \u0026#39;if\u0026#39;, \u0026#39;then\u0026#39; and \u0026#39;else\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } }, \u0026#34;then\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;bar\u0026#34; ] }, \u0026#34;else\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;baz\u0026#34; ] } } Valid\rAn object instance that conforms to both the \u0026#39;if\u0026#39; and \u0026#39;then\u0026#39; subschemas is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Invalid\rAn object instance conforming to the \u0026#39;if\u0026#39; subschema and not conforming to the \u0026#39;then\u0026#39; subschema is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Valid\rAn object instance not conforming to the \u0026#39;if\u0026#39; subschema but conforming to the \u0026#39;else\u0026#39; subschema is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Invalid\rAn object instance that does not conform to both the \u0026#39;if\u0026#39; and \u0026#39;else\u0026#39; subschemas is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34; } Schema with \u0026#39;if\u0026#39; and \u0026#39;else\u0026#39; without \u0026#39;then\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } }, \u0026#34;else\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;baz\u0026#34; ] } } Valid\rAn object instance that does not conform to the \u0026#39;if\u0026#39; subschema but conforms to the \u0026#39;else\u0026#39; subschemas is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Invalid\rIf an instance does not conform to the \u0026#39;if\u0026#39; subschema, then it must conform to the \u0026#39;else\u0026#39; subschema\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34; } Valid\rAn object instance conforming to the \u0026#39;if\u0026#39; subschemas is always valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } ","permalink":"http://localhost:1313/2020-12/applicator/else/","tags":["applicator"],"title":"else"},{"contents":"The if keyword is used to conditionally apply a subschema based on whether a certain condition is met. It allows you to define different validation rules depending on whether an instance satisfies a condition or not. The validation outcome of this keyword\u0026rsquo;s subschema has no direct effect on the overall validation result. Rather, it controls which of the then or else keywords are evaluated.\nIf an instance passes the validation against the if subschema, then it must also be validated against the then subschema, if present. If an instance fails the validation against the if subschema, then it must also be validated against the else subschema, if present. This keyword is meaningless without then and else. The annotations are collected from this keyword\u0026rsquo;s subschema in the usual way, irrespective of whether then and else are present or not. Examples Schema with \u0026#39;if\u0026#39;, \u0026#39;then\u0026#39; and \u0026#39;else\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;role\u0026#34;: { \u0026#34;enum\u0026#34;: [ \u0026#34;HOD\u0026#34;, \u0026#34;professor\u0026#34; ] }, \u0026#34;HOD_Id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;professor_Id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } }, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;role\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;HOD\u0026#34; } } }, \u0026#34;then\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;HOD_Id\u0026#34; ] }, \u0026#34;else\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;professor_Id\u0026#34; ] } } Valid\rAn instance adhering to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;HOD\u0026#34;, \u0026#34;HOD_Id\u0026#34;: 2844 } Invalid\r\u0026#39;professor_Id\u0026#39; is required when the value of role is \u0026#39;professor\u0026#39;\rInstance\r{ \u0026#34;role\u0026#34;: \u0026#34;professor\u0026#34; } Valid\rAny object instance without the \u0026#39;role\u0026#39; property is valid\rInstance\r{ \u0026#34;professor_Id\u0026#34;: 2899, \u0026#34;HOD_Id\u0026#34;: 2844 } Invalid\rthe value of \u0026#39;HOD_Id\u0026#39; must be a string\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;role\u0026#34;: \u0026#34;HOD\u0026#34;, \u0026#34;HOD_Id\u0026#34;: \u0026#34;2844\u0026#34; } Schema with \u0026#39;if\u0026#39; and \u0026#39;then\u0026#39; without \u0026#39;else\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } }, \u0026#34;then\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;bar\u0026#34; ] } } Valid\rAn object instance conforming to the \u0026#39;if\u0026#39; and \u0026#39;then\u0026#39; subschemas is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Invalid\rIf an instance conforms to the \u0026#39;if\u0026#39; subschema, then it must also conform to the \u0026#39;then\u0026#39; subschema\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Valid\rAn object instance not conforming to the \u0026#39;if\u0026#39; subschemas is always valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Schema with \u0026#39;if\u0026#39; and \u0026#39;else\u0026#39; without \u0026#39;then\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } }, \u0026#34;else\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;baz\u0026#34; ] } } Valid\rAn object instance that does not conform to the \u0026#39;if\u0026#39; subschema but conforms to the \u0026#39;else\u0026#39; subschemas is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Invalid\rIf an instance does not conform to the \u0026#39;if\u0026#39; subschema, then it must conform to the \u0026#39;else\u0026#39; subschema\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34; } Valid\rAn object instance conforming to the \u0026#39;if\u0026#39; subschemas is always valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Note: If an instance passes the if subschema and the then subschema is not present, then the then subschema behaves as a boolean true schema. Similarly, if an instance fails the if subschema and the else subschema is not present, then the else subschema behaves as a boolean true schema. Schema with \u0026#39;if\u0026#39; without \u0026#39;then\u0026#39; and \u0026#39;else\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;This is foo!\u0026#34;, \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } } } Valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/if/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/if/properties/foo/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;This is foo!\u0026#34; } Here, the annotations are collected from if’s subschema in the usual way, irrespective of whether then and else are present or not. ","permalink":"http://localhost:1313/2020-12/applicator/if/","tags":["applicator"],"title":"if"},{"contents":"The items keyword is used to validate arrays of arbitrary length where each item in the array matches the same schema. It applies its subschema to all instance items at indexes greater than the length of the prefixItems array in the same schema, or to all instance array elements if prefixItems is not present. This means that the subschema specified under items will be used to validate every item in the array that isn\u0026rsquo;t covered by prefixItems.\nIf the items subschema is applied to any positions within the instance array, it produces an annotation result of boolean true, indicating that all remaining array elements have been evaluated against this keyword\u0026rsquo;s subschema. This annotation affects the behavior of unevaluatedItems in the Unevaluated vocabulary.\nprefixItems allows defining a fixed-length sequence of schemas for an array\u0026rsquo;s initial items. items applies its sub-schema to all elements after the prefixItems sequence (if present). Analogous to additionalProperties for objects, items specifies a schema that each item in the array must adhere to. If an array has additional items beyond what\u0026rsquo;s defined in prefixItems, they must conform to the schema specified under items. Examples Schema with \u0026#39;items\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Valid\rAn array instance with all items as numeric values is valid\rInstance\r[ 2, 3, 44, -5 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/items\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Invalid\rAn array instance containing a string value is invalid\rInstance\r[ 2, 3, \u0026#34;44\u0026#34;, -5 ] Schema with \u0026#39;items\u0026#39; set to boolean true\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: true } Valid\rAn array instance with all items as numeric values is valid\rInstance\r[ 2, 3, 44, -5 ] Valid\rAn array instance containing a string value is also valid\rInstance\r[ 2, 3, \u0026#34;44\u0026#34;, -5 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/items\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Similarly, if the items is set to false, all the array instances will fail validation. Schema with \u0026#39;items\u0026#39; and \u0026#39;prefixItems\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Valid\rAn array instance adhering to the schema is valid\rInstance\r[ false, \u0026#34;44\u0026#34;, -5 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 1 } { \u0026#34;keyword\u0026#34;: \u0026#34;/items\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Invalid\rThe prefix items of the array instance must adhere to the subschemas in \u0026#39;prefixItems\u0026#39; at their respective indexes\rInstance\r[ 2, 3, \u0026#34;44\u0026#34;, -5 ] ","permalink":"http://localhost:1313/2020-12/applicator/items/","tags":["applicator","annotation"],"title":"items"},{"contents":"The not keyword is used to declare that an instance only validates if it doesn\u0026rsquo;t validate against the given subschema. It is essentially a way to define a rule that an instance should not match.\nThe boolean false schema, can be thought as an alias to { not: {} }. Annotations are dropped when an instance fails. Therefore, in the case of not, annotations are always dropped because:\nIf the subschema of not passes (producing annotations), then not itself fails, resulting in the annotations being dropped. If the subschema of not fails, no annotations are produced, and there is nothing for not to pass on. Examples Schema with \u0026#39;not\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;not\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } Valid\rAn instance with values other than string is valid\rInstance\r77 Invalid\rAn instance with a string value is invalid\rInstance\r\u0026#34;foo\u0026#34; Schema with \u0026#39;not\u0026#39; set to false\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;not\u0026#34;: false } Valid\rAny instance is valid against the above schema\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; } Since the boolean false schema is equivalent to { \u0026quot;not\u0026quot;: {} }, the overall schema translates to { \u0026quot;not\u0026quot;: { \u0026quot;not\u0026quot;: {} } }, which is equivalent to an empty object schema ({}). Therefore, every instance passes against the above schema. ","permalink":"http://localhost:1313/2020-12/applicator/not/","tags":["applicator"],"title":"not"},{"contents":"The oneOf keyword allows you to specify that exactly one of the provided subschemas must validate successfully against a given instance. It ensures that the instance validates against one and only one of the defined subschemas within the oneOf array. This behavior is akin to a logical \u0026ldquo;XOR\u0026rdquo; (exclusive OR) operation, where only one condition needs to be met for validation to pass.\nExamples Schema with \u0026#39;oneOf\u0026#39; keyword containing only one subschema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;oneOf\u0026#34;: [ { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Valid\rAn instance conforming to only one subschema of \u0026#39;oneOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rThe value of \u0026#39;foo\u0026#39; must be a string\rInstance\r{ \u0026#34;foo\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Schema with \u0026#39;oneOf\u0026#39; keyword containing multiple subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;oneOf\u0026#34;: [ { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] }, { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;bar\u0026#34; ] } ] } Valid\rAn instance conforming to only one of the subschemas of \u0026#39;oneOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rAn instance that does not conform to any of the subschemas of \u0026#39;oneOf\u0026#39; is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: 33, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Invalid\rAn instance conforming to all the subschemas of \u0026#39;oneOf\u0026#39; is also invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 33 } Schema with \u0026#39;oneOf\u0026#39; keyword containing some boolean subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;oneOf\u0026#34;: [ false, { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Valid\rAn instance conforming to the second subschema of \u0026#39;oneOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Invalid\rAn instance not conforming to the second subschema of \u0026#39;oneOf\u0026#39; is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: false } Schema with \u0026#39;oneOf\u0026#39; keyword containing some boolean subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;oneOf\u0026#34;: [ true, { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } ] } Invalid\rAn instance conforming to the second subschema of \u0026#39;oneOf\u0026#39; is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Valid\rAn instance not conforming to the second subschema of \u0026#39;oneOf\u0026#39; is valid\rInstance\r{ \u0026#34;foo\u0026#34;: true } Remember, if any subschema within the oneOf keyword passes validation or has a boolean true value, the all the other subschemas within oneOf must fail the validation for the overall validation of the oneOf keyword to be true. Schema with nested \u0026#39;oneOf\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;oneOf\u0026#34;: [ { \u0026#34;oneOf\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } ] }, { \u0026#34;oneOf\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ] } ] } Valid\rAn instance conforming to only the first subschema within \u0026#39;oneOf\u0026#39; is valid\rInstance\r25 Valid\rAn instance conforming to only the second subschema within \u0026#39;oneOf\u0026#39; is valid\rInstance\r\u0026#34;25\u0026#34; Invalid\rAn instance not conforming to any of the subschemas within \u0026#39;oneOf\u0026#39; is invalid\rInstance\r[ \u0026#34;25\u0026#34; ] ","permalink":"http://localhost:1313/2020-12/applicator/oneof/","tags":["applicator"],"title":"oneOf"},{"contents":"The patternProperties keyword is a variant of properties with regular expression support. It maps regular expressions to schemas. If a property name matches the given regular expression, the property value must validate against the corresponding schema.\nExamples Schema with \u0026#39;patternProperties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;patternProperties\u0026#34;: { \u0026#34;^[Nn]ame$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;^[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } Valid\rAn object instance with properties matching the regex and conforming to the corresponding schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 21 } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34; ] } Invalid\rAn object instance with properties matching the regex and not conforming to the corresponding schema is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;21\u0026#34; } Annotations are not produced when validation fails. Schema with patternProperties with boolean schemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;patternProperties\u0026#34;: { \u0026#34;^f.*\u0026#34;: true, \u0026#34;^b.*\u0026#34;: false } } Valid\rAn instance with properties not matching any regex is valid\rInstance\r{ \u0026#34;zbaz\u0026#34;: \u0026#34;zbaz\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [] } Note: If patternProperties does not match anything, it is still expected to produce an empty array annotation. Invalid\rAn instance with properties matching the regex with a \u0026#39;false\u0026#39; schema is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Valid\rAn instance with properties matching the regex with a \u0026#39;true\u0026#39; schema, or/and with additional properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Schema with overlap between \u0026#39;patternProperties\u0026#39; and \u0026#39;properties\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;^f\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Invalid\rThe value of \u0026#39;foo\u0026#39; property must be a string\rInstance\r{ \u0026#34;foo\u0026#34;: [ \u0026#34;bar\u0026#34; ] } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Schema with \u0026#39;patternProperties\u0026#39;, \u0026#39;properties\u0026#39; and \u0026#39;additionalProperties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;additionalProperties\u0026#34;: true } Invalid\rThe value of the \u0026#39;name\u0026#39; property must be a string\rInstance\r{ \u0026#34;name\u0026#34;: [ \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34; ], \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;Age\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/additionalProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;email\u0026#34; ] } Instance properties (keys) not present in properties or not matching any regex within patternProperties are evaluated against additionalProperties. ","permalink":"http://localhost:1313/2020-12/applicator/patternproperties/","tags":["applicator","annotation"],"title":"patternProperties"},{"contents":"The prefixItems keyword is used to validate arrays by applying a schema to each corresponding index of the array. It differs from the items keyword in that it validates only a prefix of the array, up to the length of the prefixItems array. Each schema specified in prefixItems corresponds to an index in the input array.\nThe annotation produced by this keyword affects the behavior of items and unevaluatedItems. items is used to validate all items in an array that are not covered by prefixItems, while prefixItems validates only a prefix of the array. prefixItems keyword does not constrain the length of the array. If the array is longer than this keyword\u0026rsquo;s value, this keyword validates only the prefix of matching length. Examples Schema with \u0026#39;prefixItems\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } ] } Valid\rAn array instance with first item as numeric values is valid\rInstance\r[ 2, false ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 0 } Invalid\rAn array instance containing a string value is invalid\rInstance\r[ \u0026#34;2\u0026#34;, 3 ] Schema with \u0026#39;prefixItems\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } ] } Valid\rItems of the array instance adhering to the corresponding subschema in \u0026#39;prefixItems\u0026#39; is valid\rInstance\r[ false, 35, [ \u0026#34;foo\u0026#34; ] ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 1 } Schema with \u0026#39;prefixItems\u0026#39; and \u0026#39;items\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Valid\rAn array instance adhering to the schema is valid\rInstance\r[ false, \u0026#34;44\u0026#34;, -5 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 1 } { \u0026#34;keyword\u0026#34;: \u0026#34;/items\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Invalid\rThe prefix items of the array instance not adhering to the corresponding subschema in \u0026#39;prefixItems\u0026#39; is invalid\rInstance\r[ 2, 3, \u0026#34;44\u0026#34;, -5 ] ","permalink":"http://localhost:1313/2020-12/applicator/prefixitems/","tags":["applicator","annotation"],"title":"prefixItems"},{"contents":"The properties keyword is used to define the properties (keys) that an object instance must or may contain. It allows you to specify the expected value of a property in an object instance. Each property within the properties object is defined by its name and a subschema describing the value expected for that property if present.\nThe annotation result of this keyword is the set of instance property names matched by this keyword. This annotation affects the behavior of additionalProperties and unevaluatedProperties.\nEach key within properties represents a property name in the object instance. Schema with \u0026#39;properties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 21 } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34; ] } Invalid\rAn object instance with properties not conforming to the schema is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;21\u0026#34; } Annotations are not produced when validation fails. Schema with properties (keys) set to boolean values\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: true, \u0026#34;bar\u0026#34;: false } } Valid\rAn instance with no defined property is valid\rInstance\r{ \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [] } Invalid\rAn instance with \u0026#39;false\u0026#39; property is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Valid\rAn instance with \u0026#39;true\u0026#39; property and additional properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Schema with no \u0026#39;additionalProperties\u0026#39; defined\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Invalid\rThe value of \u0026#39;Age\u0026#39; must be a number\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: \u0026#34;21\u0026#34;, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;@\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;com\u0026#34; ] } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;Age\u0026#34; ] } If you don\u0026rsquo;t define a property using properties or patternProperties, but don\u0026rsquo;t disallow it with additionalProperties, it would still be valid with any value. Schema with \u0026#39;properties\u0026#39;, \u0026#39;patternProperties\u0026#39; and \u0026#39;additionalProperties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;additionalProperties\u0026#34;: true } Invalid\rThe value of the \u0026#39;name\u0026#39; property must be a string\rInstance\r{ \u0026#34;name\u0026#34;: [ \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34; ], \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Valid\rAn object instance with properties conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;Age\u0026#34;: 21, \u0026#34;email\u0026#34;: \u0026#34;foo@bar.com\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;name\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;Age\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/additionalProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;email\u0026#34; ] } Property names not present in properties or patternProperties are evaluated against additionalProperties. ","permalink":"http://localhost:1313/2020-12/applicator/properties/","tags":["applicator","annotation"],"title":"properties"},{"contents":"The propertyNames keyword in is used to define constraints on the property names within an object instance. It allows you to specify a schema that all the property names in an object instance must adhere to.\nCommon Pitfall\rNote: Note that the property names in any object instance will always be strings. Therefore, this schema only makes sense when applied to strings. Passing a schema here that matches something other than a string would be invalid.\rExamples Schema with \u0026#39;propertyNames\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;propertyNames\u0026#34;: { \u0026#34;maxLength\u0026#34;: 3 } } Valid\rAn object instance with the length of property names less than or equal to 3 is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 33 } Invalid\rThe length of any property name must not be greater than 3\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 21 } Schema with \u0026#39;propertyNames\u0026#39; set to true\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;propertyNames\u0026#34;: true } Valid\rAn object instance with any property name is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; } Valid\rAn instance with an array is valid\rInstance\r[ \u0026#34;no\u0026#34;, \u0026#34;effect\u0026#34; ] propertyNames has no effect on instances other than objects. Schema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;propertyNames\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Invalid\rAn object instance with any property is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: 22 } Valid\rAn empty object is valid\rInstance\r{} The property names in any object instance cannot be a number. Therefore, any object instance will fail against the above schema, except for an empty object. ","permalink":"http://localhost:1313/2020-12/applicator/propertynames/","tags":["applicator"],"title":"propertyNames"},{"contents":"The then keyword is used in conjunction with if to define a schema to be applied when a condition specified in the if keyword is true. It allows you to apply additional validation logic based on whether certain conditions are met.\nThis keyword has no effect when if is absent. This keyword has no effect when the instance fails validation against the if subschema. Examples Schema with \u0026#39;if\u0026#39;, \u0026#39;then\u0026#39; and \u0026#39;else\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } }, \u0026#34;then\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;bar\u0026#34; ] }, \u0026#34;else\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;baz\u0026#34; ] } } Valid\rAn object instance that conforms to both the \u0026#39;if\u0026#39; and \u0026#39;then\u0026#39; subschemas is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Invalid\rAn object instance conforming to the \u0026#39;if\u0026#39; subschema and not conforming to the \u0026#39;then\u0026#39; subschema is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Valid\rAn object instance not conforming to the \u0026#39;if\u0026#39; subschema but conforming to the \u0026#39;else\u0026#39; subschema is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Invalid\rAn object instance that does not conform to both the \u0026#39;if\u0026#39; and \u0026#39;else\u0026#39; subschemas is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34; } Schema with \u0026#39;if\u0026#39; and \u0026#39;then\u0026#39; without \u0026#39;else\u0026#39;\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } }, \u0026#34;then\u0026#34;: { \u0026#34;required\u0026#34;: [ \u0026#34;bar\u0026#34; ] } } Valid\rAn object instance conforming to both the \u0026#39;if\u0026#39; and \u0026#39;then\u0026#39; subschemas is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Invalid\rIf an instance conforms to the \u0026#39;if\u0026#39; subschema, then it must also conform to the \u0026#39;then\u0026#39; subschema\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Valid\rAn object instance not conforming to the \u0026#39;if\u0026#39; subschemas is always valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } ","permalink":"http://localhost:1313/2020-12/applicator/then/","tags":["applicator"],"title":"then"},{"contents":"The contentEncoding keyword is an annotation used to specify the encoding used to store the contents of a string, particularly when it represents binary data. It indicates how the string value should be interpreted and decoded. This keyword is not directly involved in the validation process but provides metadata about the content.\ncontentEncoding doesn\u0026rsquo;t enforce strict validation. However, it\u0026rsquo;s recommended to use it correctly to ensure compatibility with applications that might interpret the encoding. It represents the type of binary encoding used for the string under question. Some of the common encodings are listed here. The JSON Schema specification doesn\u0026rsquo;t publish a predefined list of possible encodings Common Encodings Encoding Description Reference \u0026quot;base16\u0026quot; Encoding scheme for binary data using a 16-character hexadecimal alphabet RFC 4648 §8 \u0026quot;base32\u0026quot; Encoding scheme for binary data using a 32-character hexadecimal alphabet RFC 4648 §6 \u0026quot;base64\u0026quot; Encoding scheme for binary data using a 64-character hexadecimal alphabet RFC 4648 §4 Examples Schema with \u0026#39;contentEncoding\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;contentEncoding\u0026#34;: \u0026#34;base64\u0026#34; } Valid\rA properly encoded base64 string is valid\rInstance\r\u0026#34;SGVsbG8gV29ybGQ=\u0026#34; // --\u0026gt; Hello World (base64 encoded) Valid\rAn incorrectly encoded base64 string is also valid\rInstance\r\u0026#34;This is not base64 encoded!\u0026#34; Valid\r\u0026#39;contentEncoding\u0026#39; is irrelevant for instances with values other than strings\rInstance\r[ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34; ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/contentEncoding\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;base64\u0026#34; } ","permalink":"http://localhost:1313/2020-12/content/contentencoding/","tags":["annotation"],"title":"contentEncoding"},{"contents":"The contentMediaType keyword in JSON Schema specifies the MIME type of the contents of a string. It is used to annotate the type of media contained within a string. It should be noted that:\nThis keyword is purely an annotation and does not directly affect validation. It describes the media type of the binary string after it has been decoded as specified in contentEncoding. It is recommended to set contentEncoding if contentMediaType is declared. Examples Schema with \u0026#39;contentMediaType\u0026#39; and \u0026#39;contentEncoding\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;contentEncoding\u0026#34;: \u0026#34;base64\u0026#34;, \u0026#34;contentMediaType\u0026#34;: \u0026#34;application/json\u0026#34; } Valid\rAn instance with a properly stringified JSON document encoded in base64 is valid\rInstance\r\u0026#34;eyAibmFtZSI6ICJKb2huIERvZSIgfQ==\u0026#34; // --\u0026gt; { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34; } Valid\rAn encoded value that represents invalid JSON data is still valid\rInstance\r\u0026#34;eyAibmFtZSI6IH0=\u0026#34; // --\u0026gt; { \u0026#34;name\u0026#34;: } Valid\rA non-string instance is ignored\rInstance\rtrue Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/contentEncoding\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;base64\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/contentMediaType\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;application/json\u0026#34; } ","permalink":"http://localhost:1313/2020-12/content/contentmediatype/","tags":["annotation"],"title":"contentMediaType"},{"contents":"The contentSchema keyword allows you to specify a schema that describes the structure of the content within a string instance, particularly when used in conjunction with the contentMediaType keyword. This is useful when the string instance contains data conforming to the JSON data model.\nHowever, it\u0026rsquo;s important to note that contentSchema is merely an annotation and is not directly involved in the validation process. Instead, applications that consume JSON Schemas must use this information as they see fit. contentSchema must be a valid JSON Schema, but it is ignored if contentMediaType is absent.\nApplications utilizing JSON Schemas are expected to use the provided contentSchema to validate content if applicable. If a schema is provided but does not match the content structure, it should be considered an error.\nExamples Schema with \u0026#39;contentSchema\u0026#39;, \u0026#39;contentMediaType\u0026#39; and \u0026#39;contentEncoding\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;contentMediaType\u0026#34;: \u0026#34;application/json\u0026#34;, \u0026#34;contentEncoding\u0026#34;: \u0026#34;base64\u0026#34;, \u0026#34;contentSchema\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34; } } Valid\rAn instance with a properly stringified JSON document encoded in base64 is valid\rInstance\r\u0026#34;eyAibmFtZSI6ICJKb2huIERvZSIgfQ==\u0026#34; // --\u0026gt; { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34; } Valid\rAn encoded value that represents invalid JSON data is still valid\rInstance\r\u0026#34;eyAibmFtZSI6IH0=\u0026#34; // --\u0026gt; { \u0026#34;name\u0026#34;: } Valid\rA non-object instance is ignored\rInstance\rtrue Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/contentMediaType\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;application/json\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/contentEncoding\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;base64\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/contentSchema\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34; } } ","permalink":"http://localhost:1313/2020-12/content/contentschema/","tags":["annotation"],"title":"contentSchema"},{"contents":"The $anchor keyword is used to assign a unique identifier to a subschema within its schema resource. This identifier can then be referenced elsewhere using the $ref keyword.\nThe $anchor keyword allows for the creation of plain reusable name fragments that aren\u0026rsquo;t tied to specific structural locations, offering a flexible alternative to using JSON Pointer fragments, which require knowledge of the schema\u0026rsquo;s structure. An anchor is resolved against the base URI of its schema resource. Examples Schema with a named anchor (identifier)\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;#string\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;string\u0026#34;: { \u0026#34;$anchor\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rAn instance with a string is valid\rInstance\r\u0026#34;Hello World!\u0026#34; Invalid\rAn instance with a number is invalid\rInstance\r44 Schema with identifiers having absolute URI\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/person/name#name\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/person/age#age\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34; ], \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/person/name\u0026#34;, \u0026#34;$anchor\u0026#34;: \u0026#34;name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/person/age\u0026#34;, \u0026#34;$anchor\u0026#34;: \u0026#34;age\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } Valid\rAn instance adhering to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 55 } Invalid\rThe value of age must be an integer\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;bar\u0026#34; } Schema with location-independent identifier having base URI change in subschema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/base\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/nested#foo\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;nested\u0026#34;, \u0026#34;$anchor\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } Valid\rAn instance with integer is valid\rInstance\r99 Invalid\rAn instance with boolean is invalid\rInstance\rtrue Here the URI Reference of foo subschema is resolved to https://example.com/nested and the named anchor is used in the URI fragment to reference this subschema. ","permalink":"http://localhost:1313/2020-12/core/anchor/","tags":["identifier"],"title":"$anchor"},{"contents":"The $comment keyword is used to provide a way for schema authors to include explanatory or clarifying comments within the schema itself. However, it\u0026rsquo;s important to note that JSON Schema implementations are required to NOT add meaning to $comment, and not even collect it as an annotation. Additionally, they may even ignore or strip it out entirely. Therefore, $comment is primarily useful for leaving notes to future editors of the schema rather than communicating with users of the schema.\nImplementations ignore $comment during validation. It will not even be collected as an annotation. It can be placed anywhere within a JSON Schema to provide additional context or explanation. Some tools might even remove this keywords for size optimization. Learn more Examples Schema with \u0026#39;$comment\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;$comment\u0026#34;: \u0026#34;This property stores the person\u0026#39;s full name.\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;$comment\u0026#34;: \u0026#34;Age must be a positive integer value.\u0026#34; } } } Valid\rComments have no effect on validation\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30 } Valid\rComments have no effect on validation\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: -10 } Although the \u0026lsquo;age\u0026rsquo; property in the above instance does not adhere to the described comment, the instance is still considered valid. ","permalink":"http://localhost:1313/2020-12/core/comment/","tags":["location"],"title":"$comment"},{"contents":"The $defs keyword provides a standardized way to define reusable subschemas within a single schema document, promoting modularity, reducing code duplication, and improving schema organization. Each subschema within $defs has a unique name, acting as a location for referencing, without directly affecting validation.\nExamples Schema that describes the age of a person\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/positiveInteger\u0026#34; } }, \u0026#34;$defs\u0026#34;: { \u0026#34;positiveInteger\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34;, \u0026#34;minimum\u0026#34;: 0 } } } Valid\rThe instance has a valid \u0026#34;age\u0026#34; property that meets the requirement specified in the \u0026#34;/$defs/positiveInteger\u0026#34; subschema\rInstance\r{ \u0026#34;age\u0026#34;: 25 } Invalid\rA string is not an integer\rInstance\r{ \u0026#34;age\u0026#34;: \u0026#34;some_string\u0026#34; } Schema for product data\rSchema\r{ \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;minItems\u0026#34;: 1, \u0026#34;items\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/product\u0026#34; }, \u0026#34;$defs\u0026#34;: { \u0026#34;product\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;minimum\u0026#34;: 0 } } } } } Valid\rThe instance has a valid array of objects with product data as described in the \u0026#34;/$defs/product\u0026#34; subschema\rInstance\r[ { \u0026#34;name\u0026#34;: \u0026#34;T-shirt\u0026#34;, \u0026#34;price\u0026#34;: 19.99 }, { \u0026#34;name\u0026#34;: \u0026#34;Mug\u0026#34;, \u0026#34;price\u0026#34;: 8.50 } ] Invalid\rThe array is empty, violating the \u0026#34;minItems\u0026#34; constraint requiring at least one product\rInstance\r[] Schema for book details\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/books\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;title\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;author\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;#author\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;title\u0026#34;, \u0026#34;author\u0026#34; ], \u0026#34;$defs\u0026#34;: { \u0026#34;author\u0026#34;: { \u0026#34;$anchor\u0026#34;: \u0026#34;author\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } } } Valid\rInstance with the required properties is valid\rInstance\r{ \u0026#34;title\u0026#34;: \u0026#34;Fundamental Physics\u0026#34;, \u0026#34;author\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 55 } } Invalid\r\u0026#39;author\u0026#39; proeprty is required\rInstance\r{ \u0026#34;title\u0026#34;: \u0026#34;Fundamental Chemistry\u0026#34; } Note: JSON Pointer isn\u0026rsquo;t the only way of accessing a subschema. You can also use the $anchor keyword to reference a subschema within $defs. ","permalink":"http://localhost:1313/2020-12/core/defs/","tags":["location"],"title":"$defs"},{"contents":"","permalink":"http://localhost:1313/2020-12/core/dynamicanchor/","tags":["identifier"],"title":"$dynamicAnchor"},{"contents":"","permalink":"http://localhost:1313/2020-12/core/dynamicref/","tags":["applicator"],"title":"$dynamicRef"},{"contents":"\rDigging Deeper\rGenerally, schema and schema resource might create confusion. Let\u0026rsquo;s clarify the terminology first:\nSchema: This refers to the entire JSON boolean or JSON object passed to an evaluator.\nSchema Resource: A schema may consist of one or more schema resources ($id boundaries). When you introduce nested schema objects with $id in your schema, you create new schema resources.\nSchema Object: This is a single subschema in the schema tree, considering only its immediate keywords and not including nested subschemas.\nRelationships:\nA schema has one or more schema resources. A schema resource has one or more schema objects. A schema object has one or more keywords. Note: A schema resource does not include its children schema resources, as they are conceptually distinct entities, despite being nested. However, all of them are part of the same schema. Refer to the last example for clarification.\nThe $id keyword declares the URI for a schema, usually set at the top level. However, any subschema has the flexibility to declare its own $id to distinguish itself with a distinct URI. Each subschema with an $id in a compound schema is called a schema resource.\nThe top-level schema resource is referred to as the root schema resource. The identifier of the root schema resource, if set, must be an absolute URI. The presence of an identifier sets a new base URI for such schema resource. It\u0026rsquo;s worth noting that if the $id identifier is a URL, it\u0026rsquo;s common for the URL to respond with the schema when accessed through a web browser, but this behavior is not mandatory; the URL primarily serves as an identifier. Additionally, for non-locatable URIs, such as those not intended for direct accessibility over the declared protocol (e.g., HTTPS), it is advisable to consider using URNs.\nNote: Check out the URI RFC to gain a deeper understanding of how resolution works, providing valuable insights into the essential role of URIs in JSON Schema.\nExamples Declaring an identifier for the schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schemas/address.json\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } Valid\rA string is valid\rInstance\r\u0026#34;123 Main Street, Anytown, USA\u0026#34; The $id keyword declares the URI http://example.com/schemas/address.json as the identifier for the schema. This URI serves as the base URI for resolving other URIs within the schema resource. Nested subschema with relative $id\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/main-schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;currentAddress\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;address\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;postalCode\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;city\u0026#34;, \u0026#34;postalCode\u0026#34; ] }, \u0026#34;permanentAddress\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;address\u0026#34; } } } Valid\rAn instance with all the required properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30, \u0026#34;currentAddress\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;Example City\u0026#34;, \u0026#34;postalCode\u0026#34;: 12345 }, \u0026#34;permanentAddress\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;Another City\u0026#34;, \u0026#34;postalCode\u0026#34;: 67890 } } The base URI for this schema is https://example.com/main-schema. The address subschema has a relative URI address, which resolving against the base URI will result into https://example.com/address. Now this URI can be used to reference the address schema from other parts of the document or external documents. Nested subschema with absolute $id\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/family-info\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;fatherName\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/name\u0026#34; }, \u0026#34;motherName\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/name\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;fatherName\u0026#34;, \u0026#34;motherName\u0026#34; ] } Valid\rAn instance with all the required properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;fatherName\u0026#34;: \u0026#34;Peter\u0026#34;, \u0026#34;motherName\u0026#34;: \u0026#34;Julia\u0026#34; } Here, the name subschema has an absolute URI https://example.com/name, which can be used to reference the name schema from other parts of the document or external documents. Schema with URN as value of $id\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;urn:example:vehicle\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;car\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;urn:example:vehicle:car\u0026#34; } }, \u0026#34;$defs\u0026#34;: { \u0026#34;car\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;urn:example:vehicle:car\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;brand\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } } } Valid\rAn instance with correct datatype is valid\rInstance\r{ \u0026#34;car\u0026#34;: { \u0026#34;brand\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;price\u0026#34;: 100000 } } When using URNs, it\u0026rsquo;s important to note that there are no relative URNs; they must be fully specified. Schema with tag URI as value of $id\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;tag:example.com,2024:schemas/person\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } } } Valid\rAn instance with correct datatype is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;72\u0026#34; } A tag URI, (defined in RFC 4151), is a type of URN used for uniquely identifying resources, typically within a specific context or domain. It consists of a \u0026rsquo;tag:\u0026rsquo; scheme followed by a date and a unique string, providing a human-readable and globally unique identifier. In JSON Schema, a tag URI can be used as the value for the $id keyword to uniquely identify the schema. Clarifying schema terminologies\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schena.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } }, \u0026#34;bar\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;baz\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Whenever a schema object has $id, a new schema resource is introduced. In our case, we have three schema resources: one with the https://example.com id, one with the foo id, and one with the bar id. The https://example.com schema resource is the root schema resource. ","permalink":"http://localhost:1313/2020-12/core/id/","tags":["identifier"],"title":"$id"},{"contents":"The $ref keyword is used to statically reference a schema. This is useful for avoiding code duplication and promoting modularity when describing complex data structures.\nCommon Pitfall\rBecause of how URI resolution works, a reference to an absolute URI does not necessarily mean the reference points to a remote resource. Conversely, a reference to a relative URI does not necessarily mean the reference points to the current schema resource.\nWhen encountering a reference, a JSON Schema implementation will first resolve it into an absolute URI given the base URI of the schema. If the resulting destination is present in the schema, it will be a local reference. Otherwise, a remote reference.\nDigging Deeper\rURIs play a central role in JSON Schema. Going through the URI RFC 3986 specification is a must for gaining a deeper understanding of references, identifiers, and anchors. More specifically, we recommend carefully studying URI resolution, URLs vs URNs, and the difference between a URI and a URI Reference.\nAdditionally, a JSON Schema reference URI may contain a JSON Pointer. For this reason, we recommend reading the JSON Pointer RFC 6901 specification, primarily its proposed URI fragment identifier representation.\nExamples Schema with a relative reference\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schemas/product.json\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;productId\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;productId\u0026#34;, \u0026#34;name\u0026#34; ], \u0026#34;$defs\u0026#34;: { \u0026#34;string\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rAn instance including all the required properties is valid\rInstance\r{ \u0026#34;productId\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;Widget\u0026#34; } Invalid\rAn object instance with name proeprty not set to string is invalid\rInstance\r{ \u0026#34;productId\u0026#34;: 217, \u0026#34;name\u0026#34;: 999 } Schema with an absolute reference to the previous schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schemas/order.json\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;schemas/product.json\u0026#34; } } } } Valid\rEach item in the \u0026#34;items\u0026#34; array includes both the \u0026#34;productId\u0026#34; and \u0026#34;name\u0026#34; properties required by the referenced product schema\rInstance\r{ \u0026#34;items\u0026#34;: [ { \u0026#34;productId\u0026#34;: 123, \u0026#34;name\u0026#34;: \u0026#34;Widget\u0026#34; }, { \u0026#34;productId\u0026#34;: 456, \u0026#34;name\u0026#34;: \u0026#34;Gadget\u0026#34; } ] } // Assuming http://example.com/schemas/product.json defines the product schema Invalid\rThe first item is missing the \u0026#34;productId\u0026#34; property and the second item is missing the \u0026#34;name\u0026#34; property required by the product schema.\rInstance\r{ \u0026#34;items\u0026#34;: [ { \u0026#34;name\u0026#34;: \u0026#34;Widget\u0026#34; }, { \u0026#34;productId\u0026#34;: 456 } ] } Schema having an absolute reference with a JSON Pointer\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schemas/product.json\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/schemas/product.json#/$defs/string\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;string\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rAn instance with a string value is valid\rInstance\r\u0026#34;John Doe\u0026#34; Invalid\rAn instance with a boolean value is invalid\rInstance\rtrue Schema having absolute reference with an anchor\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schemas/product.json\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/schemas/product.json#string\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;string\u0026#34;: { \u0026#34;$anchor\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } } } Valid\rAn instance with a boolean value is valid\rInstance\rfalse Invalid\rAn instance with a numeric value is invalid\rInstance\r99 Schema with a JSON Pointer\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34; ], \u0026#34;$defs\u0026#34;: { \u0026#34;string\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rInstance including all the required properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34; } Invalid\rInstance with name property set to boolean is invalid\rInstance\r{ \u0026#34;name\u0026#34;: true } Schema with an anchor\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;counter\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;#counter\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;counter\u0026#34; ], \u0026#34;$defs\u0026#34;: { \u0026#34;string\u0026#34;: { \u0026#34;$anchor\u0026#34;: \u0026#34;counter\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } Valid\rInstance including all the required properties is valid\rInstance\r{ \u0026#34;counter\u0026#34;: 51 } Invalid\rInstance with counter property set to string is invalid\rInstance\r{ \u0026#34;counter\u0026#34;: \u0026#34;59\u0026#34; } Schema with \u0026#39;$id\u0026#39; set to URN\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;urn:example:vehicle\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;urn:example:phone\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;phone\u0026#34;: { \u0026#34;$id\u0026#34;: \u0026#34;urn:example:phone\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } Valid\rAn instance with a numeric value is valid\rInstance\r7843559621 Invalid\rAn instance with a value other than a number is invalid\rInstance\r{ \u0026#34;phone\u0026#34;: 9866548907 } ","permalink":"http://localhost:1313/2020-12/core/ref/","tags":["applicator"],"title":"$ref"},{"contents":"The $schema keyword is a fundamental element in JSON Schema. It serves the two crucial purposes:\nDialect Identification: It specifies the specific dialect of JSON Schema the schema adheres to. This ensures implementations (tools and libraries) interpret the schema correctly based on the intended dialect\u0026rsquo;s rules and imported vocabularies.\nMeta-Schema Validation: The value of $schema is a URI pointing to a \u0026ldquo;meta-schema\u0026rdquo;, which defines the structure and validation rules for JSON Schemas. A schema that describes another schema is called a \u0026ldquo;meta-schema\u0026rdquo;. The schema is expected to be valid against its own meta-schema.\nThe current schema must be valid against the meta-schema identified by this URI. The $schema keyword should be used in the document root schema object, and may be used in the root schema objects of embedded schema resources. If this keyword is absent from the document root schema, the resulting behavior is implementation-defined. Best Practice\rDeclaring $schema is highly recommended for several reasons. It ensures clarity by explicitly stating the version of JSON Schema the schema follows. This helps JSON Schema implementations (tools and libraries) understand how to interpret and validate the schema accurately. JSON Schema versions may introduce new keywords or modify existing ones. By specifying the $schema, you establish the specific vocabulary that applies to your schema, preventing ambiguity, especially if you\u0026rsquo;re using custom keywords. The schema is expected to successfully validate against its own meta-schema, ensuring its correctness and adherence to the JSON Schema standard. In scenarios where schemas are bundled together, you might encounter nested $schema keywords within the same resource. Each nested schema should still have its own $schema property to indicate its specific dialect. Examples This declaration indicates that the schema is described by the JSON Schema 2020-12 dialect\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } Schema not adhering to its meta-schema is invalid\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } ] } The properties keyword can only be set to a single valid JSON Schema. Therefore, setting the properties keyword to an array of JSON Schemas makes the schema invalid according to the 2020-12 specification. Schema with no dialect specified\rSchema\r{ \u0026#34;items\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } ] } The above schema doesn\u0026rsquo;t specify the dialect of JSON Schema it adheres to. Therefore, the implementation might determine the dialect independently, which could lead to unexpected results. For instance, if the implementation assumes the 2019-09 dialect, the schema would be considered valid. However, if it assumes the 2020-12 dialect, the schema would be invalid. Schema with nested \u0026#39;$schema\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Product schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;price\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;discount\u0026#34;: { \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/discount\u0026#34; } }, \u0026#34;$defs\u0026#34;: { \u0026#34;discount\u0026#34;: { \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2019-09/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } Embedded schemas within a bundled JSON document can have their own $schema declarations. This allows different parts of your schema to use the most suitable dialect for their specific needs, ensuring accurate validation and flexibility. Check out this blog to learn more about schema bundling. ","permalink":"http://localhost:1313/2020-12/core/schema/","tags":["identifier"],"title":"$schema"},{"contents":"The $vocabulary keyword is used in meta-schemas to identify the vocabularies available for use in schemas described by that meta-schema. It is also used to indicate whether each vocabulary is required or optional, in the sense that an implementation must understand the required vocabularies in order to successfully process the schema.\nRequired and optional vocabularies: If a vocabulary is required and an implementation does not recognize it, it must refuse to process any schemas that declare this meta-schema. If a vocabulary is optional, implementations that do not recognize it should proceed with processing such schemas.\nMandatory: The Core vocabulary MUST always be included and set as required.\nNon-inheritability: Vocabularies defined in one meta-schema do not automatically apply to another meta-schema that references it. Each meta-schema must declare its vocabularies independently.\nRecommendation: Meta-schemas should always declare this keyword to clearly specify the vocabularies in use and avoid ambiguities.\nExamples \u0026#39;$vocabulary\u0026#39; for default official-2020-12 meta-schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$vocabulary\u0026#34;: { \u0026#34;https://json-schema.org/draft/2020-12/vocab/core\u0026#34;: true, \u0026#34;https://json-schema.org/draft/2020-12/vocab/applicator\u0026#34;: true, \u0026#34;https://json-schema.org/draft/2020-12/vocab/unevaluated\u0026#34;: true, \u0026#34;https://json-schema.org/draft/2020-12/vocab/validation\u0026#34;: true, \u0026#34;https://json-schema.org/draft/2020-12/vocab/meta-data\u0026#34;: true, \u0026#34;https://json-schema.org/draft/2020-12/vocab/format-annotation\u0026#34;: true, \u0026#34;https://json-schema.org/draft/2020-12/vocab/content\u0026#34;: true }, \u0026#34;allOf\u0026#34; : [ { \u0026#34;$ref\u0026#34;: \u0026#34;meta/core\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;meta/applicator\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;meta/unevaluated\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;meta/validation\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;meta/meta-data\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;meta/format-annotation\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;meta/content\u0026#34; } ], // ... } Vocabulary meta-schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/meta/example-vocab\u0026#34;, \u0026#34;$dynamicAnchor\u0026#34;: \u0026#34;meta\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;object\u0026#34;, \u0026#34;boolean\u0026#34; ], \u0026#34;properties\u0026#34;: { \u0026#34;minDate\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;\\\\d\\\\d\\\\d\\\\d-\\\\d\\\\d-\\\\d\\\\d\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;date\u0026#34; } } } Digging Deeper\rThe $dynamicAnchor: meta declaration is set by convention to meta on the official meta-schemas. This setting serves as a mechanism to enable meta-schema extensibility. By declaring $dynamicAnchor: meta here, JSON Schema is configured to validate every subschema of the instance schema against the meta-schema, extending validation beyond just the top level.\rMeta-schema with the above vocabulary as required\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schema-required\u0026#34;, \u0026#34;$dynamicAnchor\u0026#34;: \u0026#34;meta\u0026#34;, \u0026#34;$vocabulary\u0026#34;: { \u0026#34;https://json-schema.org/draft/2020-12/vocab/core\u0026#34;: true, \u0026#34;https://example.com/vocab/example-vocab\u0026#34;: \u0026#34;true\u0026#34; }, \u0026#34;allOf\u0026#34;: [ { \u0026#34;$ref\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/meta/core\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/meta/example-vocab\u0026#34; } ] } Meta-schema with the above vocabulary as optional\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schema-optional\u0026#34;, \u0026#34;$dynamicAnchor\u0026#34;: \u0026#34;meta\u0026#34;, \u0026#34;$vocabulary\u0026#34;: { \u0026#34;https://json-schema.org/draft/2020-12/vocab/core\u0026#34;: true, \u0026#34;https://example.com/vocab/example-vocab\u0026#34;: \u0026#34;false\u0026#34; }, \u0026#34;allOf\u0026#34;: [ { \u0026#34;$ref\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/meta/core\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;https://example.com/meta/example-vocab\u0026#34; } ] } Schema that uses the above meta-schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://example.com/schema-required\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://my-schema.com\u0026#34;, \u0026#34;minDate\u0026#34;: \u0026#34;2024-05-17\u0026#34; } ","permalink":"http://localhost:1313/2020-12/core/vocabulary/","tags":["identifier"],"title":"$vocabulary"},{"contents":"Explanation The format keyword in JSON Schema\u0026rsquo;s Format Annotation vocabulary serves to provide basic semantic identification of certain types of string values. Compared to older JSON Schema versions, the format keyword in the official 2020-12 dialect is purely an annotation meant to be informative and to carry semantics rather than to perform any validation.\nWhen using format from Format Annotation, it\u0026rsquo;s recommended that you provide your validation rules alongside the format. The implementation may choose to treat format as an assertion and attempt to validate the value\u0026rsquo;s conformance to the specified semantics. However, this behavior must be explicitly enabled and is typically disabled by default. Implementations should document their level of support for such validation.\n`It allows for the semantic identification of certain kinds of string values. For instance, it can indicate that a string value should be interpreted as a date, email, URI, etc. format is solely an annotation and does not enforce any validation. It\u0026rsquo;s meant to provide information about the expected format of the string. Implementations may choose to enable format as an assertion, meaning that validation fails if the value doesn\u0026rsquo;t conform to the specified format semantics. However, this is not mandatory and must be explicitly enabled. While users can define and use their own custom formats (e.g., \u0026ldquo;format\u0026rdquo;: \u0026ldquo;foobar\u0026rdquo;), it\u0026rsquo;s recommended to refrain from overloading the format keyword for future compatibility reasons. Instead, define custom keywords for specific validation requirements. For example in the event that you define your own \u0026ldquo;foobar\u0026rdquo; and JSON Schema subsequently chooses to define \u0026ldquo;foobar,\u0026rdquo; you may encounter difficulties. Defined Formats Format Category Specification \u0026quot;date-time\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;date\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;time\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;duration\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;email\u0026quot; Emails https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.2 \u0026quot;idn-email\u0026quot; Emails https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.2 \u0026quot;hostname\u0026quot; Hostnames https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.3 \u0026quot;idn-hostname\u0026quot; Hostnames https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.3 \u0026quot;ipv4\u0026quot; IP Addresses https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.4 \u0026quot;ipv6\u0026quot; IP Addresses https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.4 \u0026quot;uri\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;uri-reference\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;iri\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;iri-reference\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;uuid\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;uri-template\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.6 \u0026quot;json-pointer\u0026quot; JSON Pointer https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.7 \u0026quot;relative-json-pointer\u0026quot; JSON Pointer https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.7 \u0026quot;regex\u0026quot; Regular Expressions https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.8 Examples Schema with \u0026#39;format\u0026#39; keyowrd with no validation rules for email\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;email\u0026#34; } Valid\rA string instance with correct email format is valid\rInstance\r\u0026#34;john.doe@example.com\u0026#34; Valid\rA string instance with incorrect email format is also valid\rInstance\r\u0026#34;foo_bar\u0026#34; Valid\r\u0026#39;format\u0026#39; keyword is irrelevant for instances with values other than strings\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/format\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;email\u0026#34; } Schema with the \u0026#39;format\u0026#39; keyword having validation rules for email\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;email\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\u0026#34; } Valid\rA string instance with correct email format is valid\rInstance\r\u0026#34;john.doe@example.com\u0026#34; Invalid\rA string instance with incorrect email format is invalid\rInstance\r\u0026#34;foo_bar\u0026#34; Valid\r\u0026#39;format\u0026#39; keyword is irrelevant for instances with values other than strings\rInstance\rtrue Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/format\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;email\u0026#34; } ","permalink":"http://localhost:1313/2020-12/format-annotation/format/","tags":["annotation"],"title":"format"},{"contents":"Explanation The format keyword of the \u0026ldquo;format-assertion\u0026rdquo; vocabulary allows for basic semantic identification of certain kinds of string values that are commonly used. It provides a way to specify logical formats for string types, such as dates, email addresses, URIs, etc. However, it\u0026rsquo;s important to note that this vocabulary is not used by default in the official 2020-12 dialect of JSON Schema. If you want to utilize it, you would need to define your own custom dialect that includes this vocabulary.\nWhile the format keyword theoretically provides interoperable logical string type validation, many existing implementations may not support this vocabulary. Therefore, it\u0026rsquo;s recommended to use the format keyword from the Format Annotation vocabulary (which is available out of the box) alongside any custom validation within the schema.\nDefined Formats Format Category Specification \u0026quot;date-time\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;date\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;time\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;duration\u0026quot; Time https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.1 \u0026quot;email\u0026quot; Emails https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.2 \u0026quot;idn-email\u0026quot; Emails https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.2 \u0026quot;hostname\u0026quot; Hostnames https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.3 \u0026quot;idn-hostname\u0026quot; Hostnames https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.3 \u0026quot;ipv4\u0026quot; IP Addresses https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.4 \u0026quot;ipv6\u0026quot; IP Addresses https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.4 \u0026quot;uri\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;uri-reference\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;iri\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;iri-reference\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;uuid\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.5 \u0026quot;uri-template\u0026quot; Resource Identifiers https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.6 \u0026quot;json-pointer\u0026quot; JSON Pointer https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.7 \u0026quot;relative-json-pointer\u0026quot; JSON Pointer https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.7 \u0026quot;regex\u0026quot; Regular Expressions https://json-schema.org/draft/2020-12/json-schema-validation.html#section-7.3.8 Examples Custom meta-schema including the \u0026#39;Format Assertion\u0026#39; vocabulary\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://example.com/custom-meta-schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/custom-meta-schema\u0026#34;, \u0026#34;$vocabulary\u0026#34;: { \u0026#34;https://json-schema.org/draft/2020-12/vocab/core\u0026#34;: true, \u0026#34;https://json-schema.org/draft/2020-12/vocab/format-assertion\u0026#34;: true }, \u0026#34;allOf\u0026#34;: [ { \u0026#34;$ref\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/meta/core\u0026#34; }, { \u0026#34;$ref\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/meta/format-assertion\u0026#34; } ] } Schema with \u0026#39;$schema\u0026#39; set to custom meta-schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://example.com/custom-meta-schema\u0026#34;, \u0026#34;$id\u0026#34;: \u0026#34;https://example.com/schema\u0026#34;, \u0026#34;format\u0026#34;: \u0026#34;email\u0026#34; } Valid\rA string instance with correct email format is valid\rInstance\r\u0026#34;john.doe@example.com\u0026#34; Invalid\rA string instance with incorrect email format is also valid\rInstance\r\u0026#34;foo_bar\u0026#34; Valid\r\u0026#39;format\u0026#39; keyword is irrelevant for instances with values other than strings\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/format\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;email\u0026#34; } ","permalink":"http://localhost:1313/2020-12/format-assertion/format/","tags":["annotation","assertion"],"title":"format"},{"contents":"The default keyword in JSON Schema is used to specify a default value for an instance. This value is not automatically used to fill in missing values during the validation process but can be used by tools such as documentation or form generators.\nNote: While it is recommended that the default value validate against its subschema, this requirement is not strictly enforced.\nExamples Schema with \u0026#39;default\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } Valid\rAn instance with a numeric value is valid\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/default\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;John\u0026#34; } Schema with logical operators\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;John\u0026#34; }, \u0026#34;qualification\u0026#34;: { \u0026#34;enum\u0026#34;: [ \u0026#34;degree\u0026#34;, \u0026#34;diploma\u0026#34; ], \u0026#34;default\u0026#34;: \u0026#34;diploma\u0026#34; } }, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;qualification\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;degree\u0026#34; } } }, \u0026#34;then\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;degreeCertificate\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;B0B8RKEZ90\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;degreeCertificate\u0026#34; ] }, \u0026#34;else\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;diplomaCertificate\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;PW458C468E\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;diplomaCertificate\u0026#34; ] } } Valid\rAn instance conforming to the schema is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;qualification\u0026#34;: \u0026#34;degree\u0026#34;, \u0026#34;degreeCertificate\u0026#34;: \u0026#34;O5CYPZACTN\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties/name/default\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/name\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;John\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/properties/qualification/default\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/qualification\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;diploma\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/then/properties/degreeCertificate/default\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/degreeCertificate\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;B0B8RKEZ90\u0026#34; } Schema with multiple annotations for the same instance\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;default\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/name\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;default\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rA string instance is valid\rInstance\r\u0026#34;Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/default\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;John\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/default\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;John\u0026#34; } ","permalink":"http://localhost:1313/2020-12/meta-data/default/","tags":["annotation"],"title":"default"},{"contents":"The deprecated keyword is used to indicate that a particular property should not be used and may be removed in the future. It provides a warning to users or applications that certain parts of the schema or are no longer recommended for use.\ndeprecated does not affect data validation but serves as an informative annotation. A true value suggests that applications should avoid using the deprecated property, and the property might be removed in future versions of the schema. Examples Schema with \u0026#39;deprecated\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;deprecated\u0026#34;: true, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } Valid\rAn instance with a numeric value is valid\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/deprecated\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Schema with logical operators\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;bar\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: true } } }, \u0026#34;then\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;deprecated\u0026#34;: true } } }, \u0026#34;else\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;deprecated\u0026#34;: false } } } } Valid\rInstance\r{ \u0026#34;foo\u0026#34;: false, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/else/properties/bar/deprecated\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/bar\u0026#34;, \u0026#34;value\u0026#34;: false } Valid\rInstance\r{ \u0026#34;foo\u0026#34;: true, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/then/properties/bar/deprecated\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/bar\u0026#34;, \u0026#34;value\u0026#34;: true } Schema with multiple annotations for the same instance\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;deprecated\u0026#34;: true, \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/name\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;deprecated\u0026#34;: true, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rInstance\r\u0026#34;John Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/deprecated\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/deprecated\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } ","permalink":"http://localhost:1313/2020-12/meta-data/deprecated/","tags":["annotation"],"title":"deprecated"},{"contents":"The description keyword in JSON Schema is used to provide a human readable description for the schema. It does not affect data validation but serves as an informative annotation.\nExamples Schema with \u0026#39;description\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;The age of a person\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } Valid\rAn instance with a numeric value is valid\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;The age of a person\u0026#34; } Schema with logical operators\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;Personal information of a user\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;if\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;if block\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Age\u0026#34;, \u0026#34;minimum\u0026#34;: 18 } } }, \u0026#34;then\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;then block\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;eligible\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Eligible\u0026#34;, \u0026#34;const\u0026#34;: true } } }, \u0026#34;else\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;else block\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;eligible\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;Not eligible\u0026#34;, \u0026#34;const\u0026#34;: false } } } } Valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;eligible\u0026#34;: true } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Personal information of a user\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/if/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;if block\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/if/properties/age/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/age\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Age\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/then/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;then block\u0026#34;, } { \u0026#34;keyword\u0026#34;: \u0026#34;/then/properties/eligible/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/eligible\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Eligible\u0026#34; } Schema with multiple annotations for the same instance\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;A person name\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/name\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;description\u0026#34;: \u0026#34;A person name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rInstance\r\u0026#34;John Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;A person name\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/description\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;A person name\u0026#34; } ","permalink":"http://localhost:1313/2020-12/meta-data/description/","tags":["annotation"],"title":"description"},{"contents":"The examples keyword is used to provide a list of example instances associated with a particular schema that should ideally validate against the schema. These examples serve to illustrate the intended structure and constraints defined by the schema. While these examples are not used for validation purposes, they are helpful in providing sample valid instances against the schema they are defined in.\nNote: While it is recommended that the examples validate against the subschema they are defined in, this requirement is not strictly enforced.\nUsed to demonstrate how data should conform to the schema. examples does not affect data validation but serves as an informative annotation. Examples Schema with \u0026#39;examples\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;examples\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;Doe\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } Valid\rAn instance with a string value is valid\rInstance\r\u0026#34;John\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/examples\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;, \u0026#34;Doe\u0026#34; ] } Schema with logical operators\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;const\u0026#34;: \u0026#34;foo\u0026#34; } } }, \u0026#34;then\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;examples\u0026#34;: [ [ \u0026#34;foo\u0026#34; ], [ \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34; ] ] } } }, \u0026#34;else\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34;, \u0026#34;examples\u0026#34;: [ false, true ] } } } } Valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: [ \u0026#34;bar\u0026#34; ] } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/then/properties/bar/examples\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/bar\u0026#34;, \u0026#34;value\u0026#34;: [ [ \u0026#34;foo\u0026#34; ], [ \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34; ] ] } Valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;not foo\u0026#34;, \u0026#34;bar\u0026#34;: true } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/else/properties/bar/examples\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/bar\u0026#34;, \u0026#34;value\u0026#34;: [ false, true ] } Schema with multiple annotations for the same instance\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;examples\u0026#34;: [ \u0026#34;John\u0026#34;, \u0026#34;Karl\u0026#34; ], \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/name\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;examples\u0026#34;: [ \u0026#34;John\u0026#34;, \u0026#34;Karl\u0026#34; ], \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rInstance\r\u0026#34;John Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/examples\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;John\u0026#34;, \u0026#34;Karl\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/examples\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;John\u0026#34;, \u0026#34;Karl\u0026#34; ] } ","permalink":"http://localhost:1313/2020-12/meta-data/examples/","tags":["annotation"],"title":"examples"},{"contents":"The readOnly keyword is used to indicate that the value of a particular property is managed exclusively by the owning authority, and attempts by an application to modify the value of this property are expected to be ignored or rejected by that authority. It essentially means that the instance value should not be modified.\nIt\u0026rsquo;s important to note that this keyword doesn\u0026rsquo;t imply the schema itself is writable; schemas must be treated as immutable. Instead, the keyword specifies instances where read/write operation semantics are use case specific.\nreadOnly does not affect data validation but serves as an informative annotation. Examples Schema with \u0026#39;readOnly\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;readOnly\u0026#34;: true, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } Valid\rAn instance with a numeric value is valid\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/readOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Schema with logical operators\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;immutable\u0026#34;: { \u0026#34;const\u0026#34;: true } } }, \u0026#34;then\u0026#34;: { \u0026#34;readOnly\u0026#34;: true }, \u0026#34;else\u0026#34;: { \u0026#34;readOnly\u0026#34;: false } } Valid\rInstance\r{ \u0026#34;immutable\u0026#34;: false } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/else/readOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: false } Valid\rInstance\r{ \u0026#34;immutable\u0026#34;: true } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/then/readOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Schema with multiple annotations for the same instance\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;readOnly\u0026#34;: true, \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/name\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;readOnly\u0026#34;: true, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rInstance\r\u0026#34;John Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/readOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/readOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } ","permalink":"http://localhost:1313/2020-12/meta-data/readonly/","tags":["annotation"],"title":"readOnly"},{"contents":"The title keyword in JSON Schema is used to provide a human-readable label for a schema or its parts. It does not affect data validation but serves as an informative annotation.\nExamples Schema with \u0026#39;title\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Age of a person\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } Valid\rAn instance with a numeric value is valid\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Age of a person\u0026#34; } Schema with logical operators\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Personal Info\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;if\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;if block\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;age\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;\u0026#39;if\u0026#39; true\u0026#34;, \u0026#34;minimum\u0026#34;: 18 } } }, \u0026#34;then\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;then block\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;eligible\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;then applied\u0026#34;, \u0026#34;const\u0026#34;: true } } }, \u0026#34;else\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;else block\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;eligible\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;else applied\u0026#34;, \u0026#34;const\u0026#34;: false } } } } Valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;eligible\u0026#34;: true } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Personal Info\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/if/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;if block\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/if/properties/age/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/age\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;\u0026#39;if\u0026#39; true\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/then/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;then block\u0026#34;, } { \u0026#34;keyword\u0026#34;: \u0026#34;/then/properties/eligible/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;/eligible\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;then applied\u0026#34; } Schema with multiple annotations for the same instance\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;title\u0026#34;: \u0026#34;Person\u0026#39;s name\u0026#34;, \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/name\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;title\u0026#34;: \u0026#34;Person\u0026#39;s name\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rInstance\r\u0026#34;John Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Person\u0026#39;s name\u0026#34; } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/title\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;Person\u0026#39;s name\u0026#34; } ","permalink":"http://localhost:1313/2020-12/meta-data/title/","tags":["annotation"],"title":"title"},{"contents":"the writeOnly keyword is used to indicate that an instance value should be writable, but it won\u0026rsquo;t be included when the instance is retrieved from the owning authority. It\u0026rsquo;s important to note that this doesn\u0026rsquo;t imply the schema itself is writable; schemas must be treated as immutable. Instead, the keyword specifies instances where read/write operation semantics are use case specific.\nwriteOnly does not affect data validation but serves as an informative annotation. Examples Schema with \u0026#39;writeOnly\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;writeOnly\u0026#34;: true, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } Valid\rAn instance with a numeric value is valid\rInstance\r45 Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/writeOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Schema with logical operators\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;if\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;sensitive\u0026#34;: { \u0026#34;const\u0026#34;: true } } }, \u0026#34;then\u0026#34;: { \u0026#34;writeOnly\u0026#34;: true }, \u0026#34;else\u0026#34;: { \u0026#34;writeOnly\u0026#34;: false } } Valid\rInstance\r{ \u0026#34;sensitive\u0026#34;: false } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/else/writeOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: false } Valid\rInstance\r{ \u0026#34;sensitive\u0026#34;: true } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/then/writeOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Schema with multiple annotations for the same instance\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;writeOnly\u0026#34;: true, \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/name\u0026#34;, \u0026#34;$defs\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;writeOnly\u0026#34;: true, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } Valid\rInstance\r\u0026#34;John Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/writeOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/writeOnly\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } ","permalink":"http://localhost:1313/2020-12/meta-data/writeonly/","tags":["annotation"],"title":"writeOnly"},{"contents":"If no relevant annotations are present, the unevaluatedItems subschema must be applied to all locations in the array. If a boolean true value is present from any of the relevant annotations, unevaluatedItems is ignored. Otherwise, the subschema must be applied to any index greater than the largest annotation value for prefixItems, which does not appear in any annotation value for contains.\nEvaluation It\u0026rsquo;s crucial to understand what evaluation means in this context.\nunevaluatedItems considers annotations from prefixItems, items, and contains, both as adjacent keywords and in subschemas of adjacent keywords. Additionally, it is also affected by other unevaluatedItems in nested schemas (if present).\nThe keywords prefixItems, items, contains and unevaluatedItems produce annotations for the indexes they successfully validate against. If any of these keywords generate an annotation for a particular index, that index is considered as evaluated. By definition, the unevaluatedItems subschema is always applied after prefixItems, items, and contains subschemas. As its name implies, unevaluatedItems applies to any array index that has not been previously evaluated. Examples Schema with \u0026#39;unevaluatedItems\u0026#39; set to boolean true\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;unevaluatedItems\u0026#34;: true } Valid\rAll array instances pass against the true schema\rInstance\r[ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34; ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/unevaluatedItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: \u0026#34;true\u0026#34; } Valid\r\u0026#39;unevaluatedItems\u0026#39; does not have any effect on instances other than an array\rInstance\r\u0026#34;John Doe\u0026#34; Here, no items are defined in the above schema. Consequently, all items in an array instance are considered unevaluated, and the unevaluatedItems subschema applies to them. Since the subschema here is a boolean true, an instance with unevaluated items, regardless of their value, is considered valid. Schema with \u0026#39;unevaluatedItems\u0026#39; set to boolean false\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;unevaluatedItems\u0026#34;: false } Invalid\rAll object instances fail against the false schema\rInstance\r[ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34; ] Valid\r\u0026#39;unevaluatedItems\u0026#39; does not have any effect on instances other than an array\rInstance\r{ \u0026#34;John\u0026#34;: 46 } Schema with \u0026#39;unevaluatedItems\u0026#39;, \u0026#39;prefixItems\u0026#39;, and \u0026#39;contains\u0026#39;, with unevaluatedItems set to boolean false\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;unevaluatedItems\u0026#34;: false } Invalid\rAn array instance with unevaluated items is invalid\rInstance\r[ \u0026#34;foo\u0026#34;, 101, false ] Valid\rAn array instance with no unevaluated items is valid\rInstance\r[ \u0026#34;foo\u0026#34;, 101, 77 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 0 } { \u0026#34;keyword\u0026#34;: \u0026#34;/contains\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ 1, 2 ] } For the first instance, the annotation result of prefixItems is 0, and the annotation result of contains is [ 1 ]. However, the item at 2nd index (i.e., false) remains unevaluated, so the unevaluatedItems subschema applies to it. This subschema fails (as any instance against a false schema is always invalid), leading to validation failure.\nFor the second instance, the annotation result of prefixItems is 0, and the annotation result of contains is [ 1, 2 ]. No items remain unevaluated; hence, the instance is considered valid.\nSchema with \u0026#39;unevaluatedItems\u0026#39;, \u0026#39;prefixItems\u0026#39;, and \u0026#39;contains\u0026#39;, with unevaluatedItems set to an object schema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;unevaluatedItems\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } } Valid\rAn array instance with no unevaluated items is valid\rInstance\r[ \u0026#34;foo\u0026#34;, 101, 77 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 0 } { \u0026#34;keyword\u0026#34;: \u0026#34;/contains\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ 1, 2 ] } Valid\rAn array instance with unevaluated items that conform to the \u0026#39;unevaluatedItems\u0026#39; subschema is valid\rInstance\r[ \u0026#34;foo\u0026#34;, 101, false ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 0 } { \u0026#34;keyword\u0026#34;: \u0026#34;/contains\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ 1 ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/unevaluatedItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Invalid\rAn array instance with unevaluated items that do not conform to the \u0026#39;unevaluatedItems\u0026#39; subschema is invalid\rInstance\r[ \u0026#34;foo\u0026#34;, 101, [ false ] ] For the first instance, there are no unevaluated items.\nFor the second instance, the item at 2nd index (i.e., false) remains unevaluated, and the unevaluatedItems subschema applies to it. This item conforms to this subschema, and hence the instance is valid.\nSchema with \u0026#39;unevaluatedItems\u0026#39;, and \u0026#39;allOf\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;allOf\u0026#34; : [ { \u0026#34;prefixItems\u0026#34;: [ true, { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } ] } ], \u0026#34;unevaluatedItems\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Valid\rAn array instance with unevaluated items that conform to the \u0026#39;unevaluatedItems\u0026#39; subschema is valid\rInstance\r[ \u0026#34;foo\u0026#34;, false, 22 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 0 } { \u0026#34;keyword\u0026#34;: \u0026#34;/allOf/0/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 1 } { \u0026#34;keyword\u0026#34;: \u0026#34;/unevaluatedItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Invalid\rAn array instance with unevaluated items that do not conform to the \u0026#39;unevaluatedItems\u0026#39; subschema is invalid\rInstance\r[ \u0026#34;foo\u0026#34;, 101, [ false ] ] For the above two instances, the annotation result of top level prefixItems is 0, and the annotation result of the nested prefixItems is 1. The unevaluatedItems recognizes the annotations from top level prefixItems as well as nested prefixItems (as it can see through adjacent and nested applicators as only the produced annotations matter, not the schema structure) and ensures that the item at index 2 remains unevaluated and its subschema applies to it.\nThe first instance passes as it conforms to the unevaluated subschema. The second instance fails as it does not conform to the unevaluated subschema. Schema with \u0026#39;unevaluatedItems\u0026#39;, and \u0026#39;allOf\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;allOf\u0026#34; : [ { \u0026#34;items\u0026#34;: true } ], \u0026#34;unevaluatedItems\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } Valid\rAn array instance with no unevaluated items is valid\rInstance\r[ \u0026#34;foo\u0026#34;, false, 22 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 0 } { \u0026#34;keyword\u0026#34;: \u0026#34;/allOf/0/items\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } Here, the nested items evaluated all the unevaluated items. So there\u0026rsquo;s nothing left unevaluated. Schema with \u0026#39;unevaluatedItems\u0026#39; and \u0026#39;#ref\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } ], \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/bar\u0026#34;, \u0026#34;unevaluatedItems\u0026#34;: false, \u0026#34;$defs\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } } Valid\rAn instance with no unevaluated items is valid\rInstance\r[ \u0026#34;foo\u0026#34;, false, 22 ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 1 } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/contains\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ 2 ] } Invalid\rAn instance with unevaluated items is invalid\rInstance\r[ \u0026#34;foo\u0026#34;, false, \u0026#34;bar\u0026#34; ] Schema with nested \u0026#39;unevaluatedItems\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;allOf\u0026#34; : [ { \u0026#34;unevaluatedItems\u0026#34;: true } ], \u0026#34;unevaluatedItems\u0026#34;: false } Valid\rNo items left unevaluated for the top level \u0026#39;unevaluatedItems\u0026#39;\rInstance\r[ \u0026#34;foo\u0026#34;, false, \u0026#34;bar\u0026#34; ] Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/prefixItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: 0 } { \u0026#34;keyword\u0026#34;: \u0026#34;/allOf/0/unevaluatedItems\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: true } ","permalink":"http://localhost:1313/2020-12/unevaluated/unevaluateditems/","tags":["applicator","annotation"],"title":"unevaluatedItems"},{"contents":"Validation with unevaluatedProperties applies only to the child values of instance names that do not appear in the properties, patternProperties, additionalProperties, or unevaluatedProperties annotation results that apply to the instance location being validated. For all such properties, validation succeeds if the child instance validates against the unevaluatedProperties schema.\nEvaluation It\u0026rsquo;s crucial to understand what evaluation means in this context.\nunevaluatedProperties considers annotations from properties, patternProperties, and additionalProperties, both as adjacent keywords and in subschemas of adjacent keywords. Additionally, it is also affected by other unevaluatedProperties in nested schemas (if present).\nThe keywords properties, patternProperties, additionalProperties, and unevaluatedProperties produce annotations for the properties they successfully validate against. If any of these keywords generate an annotation for a particular property at the same instance location (independently of the schema location), that property is considered as evaluated. By definition, the unevaluatedProperties subschema is always applied after properties, patternProperties, and additionalProperties subschemas. As its name implies, unevaluatedProperties applies to any object property that has not been previously evaluated. Examples Schema with \u0026#39;unevaluatedProperties\u0026#39; set to boolean true\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;unevaluatedProperties\u0026#34;: true } Valid\rAll object instances pass against the true schema\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;: 33 } Valid\r\u0026#39;unevaluatedProperties\u0026#39; does not have any effect on instances other than an object\rInstance\r\u0026#34;John Doe\u0026#34; Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/unevaluatedProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;baz\u0026#34; ] } Here, no properties are defined in the above schema. Consequently, all properties in an object instance are considered unevaluated, and the unevaluatedProperties subschema applies to them. Since the subschema here is a boolean true, an instance with unevaluated properties, regardless of their value, is considered valid. Schema with \u0026#39;unevaluatedProperties\u0026#39; set to boolean false\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;unevaluatedProperties\u0026#34;: false } Invalid\rAll object instances fail against the false schema\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; } Valid\r\u0026#39;unevaluatedProperties\u0026#39; does not have any effect on instances other than an object\rInstance\r[ \u0026#34;John\u0026#34;, 46, false ] Schema with \u0026#39;unevaluatedProperties\u0026#39;, \u0026#39;properties\u0026#39;, and \u0026#39;patternProperties\u0026#39;, with unevaluatedProperties set to boolean false\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;^b\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;unevaluatedProperties\u0026#34;: false } Invalid\rAn instance with unevaluated properties is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 36, \u0026#34;fooBar\u0026#34;: false } Valid\rAn instance with no unevaluated properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 36 } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;bar\u0026#34; ] } For the first instace, the annotation result of properties is [ \u0026ldquo;foo\u0026rdquo; ], and the annotation result of patternProperties is [ \u0026ldquo;bar\u0026rdquo; ]. However, the \u0026lsquo;fooBar\u0026rsquo; property remains unevaluated, so the unevaluatedProperties subschema applies to it. This subschema fails (as any instance against a false schema is always invalid), leading to the failure of the entire schema. For the second instace, the annotation result of properties is [ \u0026ldquo;foo\u0026rdquo; ], and the annotation result of patternProperties is [ \u0026ldquo;bar\u0026rdquo; ]. No properties remain unevaluated; hence, the instance is considered valid. Schema with \u0026#39;unevaluatedProperties\u0026#39;, \u0026#39;properties\u0026#39;, and \u0026#39;patternProperties\u0026#39;, with unevaluatedProperties set to an object subschema\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;patternProperties\u0026#34;: { \u0026#34;^b\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;unevaluatedProperties\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } } Valid\rAn instance with no unevaluated properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 36 } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;bar\u0026#34; ] } Valid\rAn instance with unevaluated properties that conform to the \u0026#39;unevaluatedProperties\u0026#39; subschema is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 36, \u0026#34;fooBar\u0026#34;: false } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;bar\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/unevaluatedProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;fooBar\u0026#34; ] } Invalid\rAn instance with unevaluated properties that do not conform to the \u0026#39;unevaluatedProperties\u0026#39; subschema is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 36, \u0026#34;fooBar\u0026#34;: \u0026#34;string\u0026#34; } For the first instance, there are no unevaluated properties. For the second instance, \u0026lsquo;fooBar\u0026rsquo; is unevaluated, and the unevaluatedProperties subschema applies to it. \u0026lsquo;fooBar\u0026rsquo; conforms to this subschema, and hence the instance is valid. The annotations produced by applicators are: properties → [ \u0026ldquo;foo\u0026rdquo; ], patternProperties → [ \u0026ldquo;bar\u0026rdquo; ], and unevaluatedProperties → [ \u0026ldquo;fooBar\u0026rdquo; ]. Schema with \u0026#39;unevaluatedProperties\u0026#39; and \u0026#39;allOf\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;allOf\u0026#34;: [ { \u0026#34;patternProperties\u0026#34;: { \u0026#34;^b\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } } } ], \u0026#34;unevaluatedProperties\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; } } Valid\rAn instance with unevaluated properties that conform to the \u0026#39;unevaluatedProperties\u0026#39; subschema is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 36, \u0026#34;fooBar\u0026#34;: false } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/allOf/0/patternProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/unevaluatedProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;fooBar\u0026#34; ] } Invalid\rAn instance with unevaluated properties that do not conform to the \u0026#39;unevaluatedProperties\u0026#39; subschema is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 36, \u0026#34;fooBar\u0026#34;: \u0026#34;string\u0026#34; } For the above two instances, the annotation result of properties is [ \u0026ldquo;foo\u0026rdquo; ], and the annotation result of nested patternProperties is [ \u0026ldquo;bar\u0026rdquo; ]. The unevaluatedProperties recognizes the annotations from properties as well as patternProperties (as it can see through adjacent and nested applicators as only the produced annotations matter, not the schema structure) and ensures that \u0026lsquo;fooBar\u0026rsquo; remains unevaluated and its subschema applies to \u0026lsquo;fooBar\u0026rsquo;.\nThe first instance passes as it conforms to the unevaluated subschema. The second instance fails as it does not conform to the unevaluated subschema. Schema with \u0026#39;unevaluatedProperties\u0026#39; and \u0026#39;allOf\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;allOf\u0026#34;: [ { \u0026#34;additionalProperties\u0026#34;: true } ], \u0026#34;unevaluatedProperties\u0026#34;: false } Valid\rAn instance with no unevaluated properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] }, { \u0026#34;keyword\u0026#34;: \u0026#34;/allOf/0/additionalProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Valid\rAn instance with no unevaluated properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/allOf/0/additionalProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34; ] } In the first case, there are no unevaluated properties. In the second case, the nested { additionalProperties: true } evaluated all the remaining properties. So there\u0026rsquo;s nothing left unevaluated. Schema with \u0026#39;unevaluatedProperties\u0026#39; and \u0026#39;#ref\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;$ref\u0026#34;: \u0026#34;#/$defs/bar\u0026#34;, \u0026#34;unevaluatedProperties\u0026#34;: false, \u0026#34;$defs\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;properties\u0026#34;: { \u0026#34;bar\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } } } } } Valid\rAn instance with no unevaluated properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34; } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/$ref/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;bar\u0026#34; ] } Invalid\rAn instance with unevaluated properties is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: \u0026#34;bar\u0026#34;, \u0026#34;baz\u0026#34;: \u0026#34;baz\u0026#34; } Schema with nested \u0026#39;unevaluatedProperties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;foo\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;allOf\u0026#34;: [ { \u0026#34;unevaluatedProperties\u0026#34;: true } ], \u0026#34;unevaluatedProperties\u0026#34;: false } Valid\rNo properties remain unevaluated for the top-level \u0026#39;unevaluatedProperties\u0026#39;\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;: 101 } Annotations\r{ \u0026#34;keyword\u0026#34;: \u0026#34;/properties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34; ] } { \u0026#34;keyword\u0026#34;: \u0026#34;/allOf/0/unevaluatedProperties\u0026#34;, \u0026#34;instance\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;value\u0026#34;: [ \u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34; ] } ","permalink":"http://localhost:1313/2020-12/unevaluated/unevaluatedproperties/","tags":["applicator","annotation"],"title":"unevaluatedProperties"},{"contents":"The const keyword in restricts an instance to a specific value. Its usage is functionally similar to an enum with a single value. Instances validate successfully only if their property value deeply matches the specified constant.\nApplies to various JSON data types, including numbers, strings, booleans, objects, and arrays. Takes precedence over other validation keywords like type and enum. Best Practice\rIt is best practice to avoid using the type keyword or any other validation keyword with const, as const takes precedence over them. Therefore, it is better not to use them together.\rExamples Schema with a specific string value\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;const\u0026#34;: \u0026#34;hello\u0026#34; } Valid\rAn instance matching the const value is valid\rInstance\r\u0026#34;hello\u0026#34; Invalid\rAn instance not matching the const value is invalid.\rInstance\r\u0026#34;world\u0026#34; Schema with a specific number value\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;const\u0026#34;: 3.14159 } Valid\rAn instance matching the const value is valid\rInstance\r3.14159 Invalid\rAn instance not matching the const value is invalid.\rInstance\r\u0026#34;pi\u0026#34; Schema with a fixed object structure\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;const\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30 } } Invalid\rAn empty object is invalid\rInstance\r{} Valid\rAn instance matching the exact object structure is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: 30 } Invalid\rAn instance not matching the exact object structure is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;Robert\u0026#34;, \u0026#34;age\u0026#34;: 30 } ","permalink":"http://localhost:1313/2020-12/validation/const/","tags":["assertion"],"title":"const"},{"contents":"The dependentRequired keyword specifies a conditional dependency between properties within an instance. It ensures that if a certain property is present in an instance, then another specified set of properties must also be present. In short, if property A exists in an instance, then properties B, C, and D must also be present.\nExamples Schema with the \u0026#39;dependentRequired\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;license\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;dependentRequired\u0026#34;: { \u0026#34;license\u0026#34;: [ \u0026#34;age\u0026#34; ] } } Valid\rAn instance with both \u0026#39;age\u0026#39; and \u0026#39;license\u0026#39; properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 25, \u0026#34;license\u0026#34;: \u0026#34;XYZ123\u0026#34; } Invalid\rAn instance with missing \u0026#39;age\u0026#39; property when \u0026#39;license\u0026#39; property is present is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;XYZ123\u0026#34; } Valid\rAn instance without \u0026#39;license\u0026#39; property is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 25 } Valid\rAn empty object is also valid\rInstance\r{} Complex schema with the \u0026#39;dependentRequired\u0026#39; keyword Schema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;productName\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;productPriceUSD\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, \u0026#34;units\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } }, \u0026#34;dependentRequired\u0026#34;: { \u0026#34;productPriceUSD\u0026#34;: [ \u0026#34;productName\u0026#34; ], \u0026#34;totalCost\u0026#34; : [ \u0026#34;productPriceUSD\u0026#34;, \u0026#34;units\u0026#34; ], \u0026#34;trackingId\u0026#34;: [ \u0026#34;outForDelivery\u0026#34; ] } } Valid\rAn instance with all the dependent properties is valid\rInstance\r{ \u0026#34;productName\u0026#34;: \u0026#34;Iphone\u0026#34;, \u0026#34;productPriceUSD\u0026#34;: 399.99, \u0026#34;units\u0026#34;: 5, \u0026#34;totalCost\u0026#34;: 1599.99, \u0026#34;trackingId\u0026#34; : 1414326241, \u0026#34;outForDelivery\u0026#34;: \u0026#34;yes\u0026#34; } Invalid\rAn instance with missing \u0026#39;productPriceUSD\u0026#39; property when \u0026#39;totalCost\u0026#39; property is present is invalid\rInstance\r{ \u0026#34;productName\u0026#34;: \u0026#34;Iphone\u0026#34;, \u0026#34;units\u0026#34;: 5, \u0026#34;totalCost\u0026#34;: 1599.99, \u0026#34;trackingId\u0026#34; : 1414326241, \u0026#34;outForDelivery\u0026#34;: \u0026#34;yes\u0026#34; } Valid\rAn instance with \u0026#39;productName\u0026#39; and \u0026#39;productPriceUSD\u0026#39; is valid\rInstance\r{ \u0026#34;productName\u0026#34;: \u0026#34;Iphone\u0026#34;, \u0026#34;productPriceUSD\u0026#34;: 399.99 } // The \u0026#39;totalCost\u0026#39; property is not present in this instance, so it will be valid regardless of the presence of \u0026#39;units\u0026#39; or \u0026#39;productPriceUSD\u0026#39; property. ","permalink":"http://localhost:1313/2020-12/validation/dependentrequired/","tags":["assertion"],"title":"dependentRequired"},{"contents":"The enum keyword specifies a validation constraint for an instance, defining a set of permissible values. The validation succeeds if the value of the instance matches one of the elements in the enum array.\nNote: Using the type keyword along the enum keyword is considered an anti-pattern, as enum constraints instances tighter than type.\nExamples Schema with string enum\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;enum\u0026#34;: [ \u0026#34;red\u0026#34;, \u0026#34;green\u0026#34;, \u0026#34;blue\u0026#34; ] } Valid\rInstance with value present in the enum is valid\rInstance\r\u0026#34;green\u0026#34; Invalid\rInstance with value not present in the enum is invalid\rInstance\r\u0026#34;black\u0026#34; Schema with number enum\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;enum\u0026#34;: [ 2, 45, 100 ] } Valid\rInstance with value present in the enum is valid\rInstance\r45 Invalid\rInstance with value not present in the enum is invalid\rInstance\r70 Invalid\rInstance with value having different datatype is invalid\rInstance\r\u0026#34;2\u0026#34; Schema with mixed-type enum\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;enum\u0026#34;: [ \u0026#34;red\u0026#34;, 123, true, { \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; }, [ 1, 2 ], null ] } Valid\rInstance with value present in the enum is valid\rInstance\rtrue Invalid\rInstance with value not present in the enum is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;baz\u0026#34; } Without specifying a type, you can utilize enum to accept values of various types. ","permalink":"http://localhost:1313/2020-12/validation/enum/","tags":["assertion"],"title":"enum"},{"contents":"The exclusiveMaximum keyword is used to set an exclusive upper limit on numeric instances. It specifies that the numeric value being validated must be strictly less than (not equal to) the provided maximum value.\nApplies only to number data types (integers and real numbers). Validation succeeds if the number is strictly less than the specified exclusiveMaximum. Examples Schema defining exclusive upper limit of 10 on numeric values\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;exclusiveMaximum\u0026#34;: 10 } Invalid\rAn instance with numeric value greater than 10 is invalid\rInstance\r15 Valid\rAn instance with numeric value less than 10 is valid\rInstance\r9.5 Invalid\rAn instance with numeric value equal to 10 is invalid\rInstance\r10 Schema allowing either a string value or a numeric value with an exclusive upper limit of 20.99\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;string\u0026#34;, \u0026#34;number\u0026#34; ], \u0026#34;exclusiveMaximum\u0026#34;: 20.99 } Valid\rAn instance with a numeric value less than 20.99 is valid\rInstance\r15.67 Invalid\rAn instance with a boolean datatype is invalid\rInstance\rtrue Valid\rAn instance with a string value is valid\rInstance\r\u0026#34;Hello World!\u0026#34; Invalid\rAn instance with a numeric value greater than 20.99 is invalid\rInstance\r29 Schema with both \u0026#39;maximum\u0026#39; and \u0026#39;exclusiveMaximum\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;exclusiveMaximum\u0026#34;: 10, \u0026#34;maximum\u0026#34;: 20 } Valid\rAn instance with numeric value less than 10 is valid\rInstance\r9.5 Invalid\rAn instance with numeric value greater than or equal to 10 is invalid\rInstance\r15 Note: Here, the exclusiveMaximum takes precedence, even though maximum is 20. Only numbers less than 10 are valid. ","permalink":"http://localhost:1313/2020-12/validation/exclusivemaximum/","tags":["assertion"],"title":"exclusiveMaximum"},{"contents":"The exclusiveMinimum keyword is used to set an exclusive lower limit on numeric instances. It specifies that the numeric value being validated must be strictly greater than (not equal to) the provided minimum value.\nApplies only to number data types (integers and real numbers). Validation succeeds if the number is strictly greater than the specified exclusiveMinimum. Examples Schema defining exclusive lower limit of 5 on numeric values\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;exclusiveMinimum\u0026#34;: 5 } Invalid\rAn instance with numeric value less than 5 is invalid\rInstance\r3 Valid\rAn instance with numeric value greater than 5 is valid\rInstance\r9.5 Invalid\rAn instance with numeric value equal to 5 is invalid\rInstance\r5 Schema allowing either a string value or a numeric value with an exclusive lower limit of 10.2\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;string\u0026#34;, \u0026#34;number\u0026#34; ], \u0026#34;exclusiveMinimum\u0026#34;: 10.2 } Valid\rAn instance with a numeric value greater than 10.2 is valid\rInstance\r15 Invalid\rAn instance with a boolean datatype is invalid\rInstance\rfalse Valid\rAn instance with a string value is valid\rInstance\r\u0026#34;Hello World!\u0026#34; Invalid\rAn instance with a numeric value less than 10.2 is invalid\rInstance\r10.01 Schema with both \u0026#39;minimum\u0026#39; and \u0026#39;exclusiveMinimum\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;exclusiveMinimum\u0026#34;: 10, \u0026#34;minimum\u0026#34;: 5 } Valid\rAn instance with numeric value greater than 10 is valid\rInstance\r15 Invalid\rAn instance with numeric value less than or equal to 10 is invalid\rInstance\r9.5 Note: Here, the exclusiveMinimum takes precedence, even though minimum is 5. Only numbers greater than 10 are valid. ","permalink":"http://localhost:1313/2020-12/validation/exclusiveminimum/","tags":["assertion"],"title":"exclusiveMinimum"},{"contents":"The maxContains keyword is used in conjunction with the contains keyword to specify the maximum number of items in an array instance that must validate against the contains subschema.\nIf contains is not present within the same schema object, then this keyword has no effect. Examples Schema with the \u0026#39;maxContains\u0026#39; and \u0026#39;contains\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;maxContains\u0026#34;: 2 } Valid\rAn array instance with 2 or less items successfully validating against the \u0026#39;contains\u0026#39; subschema is valid\rInstance\r[ \u0026#34;Car\u0026#34;, \u0026#34;Bus\u0026#34;, 1, 2 ] Invalid\rAn array instance with more than 2 items successfully validating against the \u0026#39;contains\u0026#39; subschema is invalid\rInstance\r[ \u0026#34;Car\u0026#34;, \u0026#34;Bus\u0026#34;, 1, 2, \u0026#34;Bike\u0026#34; ] Schema with the \u0026#39;maxContains\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;maxContains\u0026#34;: 2 } // If contains is not present, \u0026#39;maxContains\u0026#39; has no effect on validation. Valid\rAn array instance with any items is valid\rInstance\r[ \u0026#34;John\u0026#34;, false, 29, { \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; }, [ 5, 7 ] ] Valid\rAn empty array is also valid\rInstance\r[] ","permalink":"http://localhost:1313/2020-12/validation/maxcontains/","tags":["assertion"],"title":"maxContains"},{"contents":"The maximum keyword is used to set the upper limit on numeric instances. It specifies that the numeric value being validated must be less than or equal to the provided maximum value.\nApplies only to number data types (integers and floats). Validation succeeds if the number is less than or equal to the specified maximum. Examples Schema defining the upper limit of 10 on numeric values\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;maximum\u0026#34;: 10 } Valid\rAn instance with a numeric value less than 10 is valid\rInstance\r9.5 Invalid\rAn instance with a numeric value greater than 10 is invalid\rInstance\r15 Valid\rAn instance with a numeric value equal to 10 is valid\rInstance\r10 Schema allowing either a boolean value or a numeric value with an upper limit of 20.99\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;boolean\u0026#34;, \u0026#34;number\u0026#34; ], \u0026#34;maximum\u0026#34;: 20.99 } Valid\rAn instance with a numeric value less than 20.99 is valid\rInstance\r15 Invalid\rAn instance with a string datatype is invalid\rInstance\r\u0026#34;Hello World!\u0026#34; Valid\rAn instance with a boolean value is valid\rInstance\rtrue ","permalink":"http://localhost:1313/2020-12/validation/maximum/","tags":["assertion"],"title":"maximum"},{"contents":"The maxItems keyword is used to specify the maximum number of items allowed in an array. It can be used to define constraints on the size of an array within an array instance.\nAn array is valid if it has less than or equal to the specified number of elements. Omitting maxItems means the array has no upper limit (unbounded). Examples Schema with \u0026#39;maxItems\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;maxItems\u0026#34;: 3 } Valid\rAn array instance with 3 or less items is valid\rInstance\r[ 1, true, \u0026#34;hello\u0026#34; ] Invalid\rAn array instance with more than 3 items is invalid\rInstance\r[ 1, 2, \u0026#34;apple\u0026#34;, \u0026#34;banana\u0026#34;, true ] Schema with the \u0026#39;maxItems\u0026#39; and \u0026#39;items\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;maxItems\u0026#34;: 2 } Valid\rAn array instance containing 2 or less items, which conform to the \u0026#39;items\u0026#39; subschema, is valid\rInstance\r[ false ] Invalid\rAn array instance with more than 2 elements is invalid\rInstance\r[ false, false, true ] Schema with the \u0026#39;maxItems\u0026#39;, \u0026#39;prefixItems\u0026#39; and \u0026#39;contains\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;maxItems\u0026#34;: 3 } Valid\rAn array instance containing 3 or less items, which successfully validates against \u0026#39;prefixItems\u0026#39; and \u0026#39;contains\u0026#39;, is valid\rInstance\r[ 1, \u0026#34;John\u0026#34;, false ] Invalid\rAn array instance with more than 3 elements is invalid\rInstance\r[ 1, \u0026#34;John\u0026#34;, \u0026#34;Doe\u0026#34;, false ] Invalid\rFirst and second items should be number and string respectively\rInstance\r[ \u0026#34;John\u0026#34;, 1, false ] ","permalink":"http://localhost:1313/2020-12/validation/maxitems/","tags":["assertion"],"title":"maxItems"},{"contents":"The maxLength keyword is used to specify the maximum length of a string instance. It is used to enforce a constraint on the maximum number of characters allowed for a string instance.\nString length is counted in characters, not bytes. Validation succeeds if the string length is less than or equal to the specified maxLength. Examples Schema restricting string length to a maximum of 10 characters\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: 10 } Valid\rAn instance with a string length less than or equal to 10 is valid\rInstance\r\u0026#34;foo\u0026#34; Invalid\rAn instance with a string length greater than 10 is invalid\rInstance\r\u0026#34;This is an invalid string\u0026#34; Schema allowing either a string with a maximum of 20 characters or a numeric value\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;string\u0026#34;, \u0026#34;number\u0026#34; ], \u0026#34;maxLength\u0026#34;: 20 } Valid\rAn instance with a string length less than or equal to 20 is valid\rInstance\r\u0026#34;This is a valid string\u0026#34; Invalid\rAn instance with a string length greater than 20 is invalid\rInstance\r\u0026#34;This description is too long\u0026#34; Valid\rAn instance with a numeric value is valid\rInstance\r55 Schema for maximum string length validation with Unicode characters\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;maxLength\u0026#34;: 3 } Valid\rAn instance with 3 or less characters is valid\rInstance\r\u0026#34;\\u0066\\u006F\\u006F\u0026#34; // --\u0026gt; \u0026#34;foo\u0026#34; Invalid\rAn instance with more than 3 characters is invalid\rInstance\r\u0026#34;\\u0048\\u0065\\u006C\\u006C\\u006F\u0026#34; // --\u0026gt; \u0026#34;Hello\u0026#34; ","permalink":"http://localhost:1313/2020-12/validation/maxlength/","tags":["assertion"],"title":"maxLength"},{"contents":"The maxProperties keyword is used to specify the maximum number of properties allowed in an object instnace. It is typically used to enforce constraints on the number of properties an object instance can have. If the number of properties in the object exceeds the value specified by maxProperties, the validation fails.\nSetting maxProperties to 0 enforces an empty object instance. Examples Schema with \u0026#39;maxProperties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;maxProperties\u0026#34;: 2 } Valid\rAn instance with 2 or less properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: 3, \u0026#34;bar\u0026#34;: \u0026#34;hi\u0026#34; } Valid\r\u0026#39;minProperties\u0026#39; has no effect on values other than objects\rInstance\rfalse Invalid\rAn instance with more than 2 properties is invalid\rInstance\r{ \u0026#34;foo\u0026#34;: 3, \u0026#34;bar\u0026#34;: \u0026#34;hi\u0026#34;, \u0026#34;baz\u0026#34;: true } Schema with \u0026#39;maxProperties\u0026#39; and \u0026#39;properties\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;maxProperties\u0026#34;: 2 } Valid\rAn instance with 2 or less properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 2 } Invalid\rAn instance with more than 2 properties is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 2, \u0026#34;address\u0026#34;: \u0026#34;22/3, GCET Road, Ahmedabad, Gujarat\u0026#34; } Schema with \u0026#39;maxProperties\u0026#39;, \u0026#39;patternProperties\u0026#39; and \u0026#39;additionalProperties\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;patternProperties\u0026#34;: { \u0026#34;^[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } }, \u0026#34;additionalProperties\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;maxProperties\u0026#34;: 2 } Valid\rAn instance with 2 or less properties is valid\rInstance\r{ \u0026#34;Age\u0026#34;: 22 } Invalid\rThe value of \u0026#39;eligible\u0026#39; property must be a boolean\rInstance\r{ \u0026#34;Age\u0026#34;: 21, \u0026#34;eligible\u0026#34;: \u0026#34;yes\u0026#34; } Valid\rAn instance with 2 or less properties is valid\rInstance\r{ \u0026#34;Age\u0026#34;: 21, \u0026#34;eligible\u0026#34;: true } Invalid\rAn instance with more than 2 properties is invalid\rInstance\r{ \u0026#34;Age\u0026#34;: 21, \u0026#34;eligible\u0026#34;: true, \u0026#34;isGraduated\u0026#34;: true } Schema with \u0026#39;maxProperties\u0026#39; and \u0026#39;required\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;address\u0026#34; ], \u0026#34;maxProperties\u0026#34;: 2 } Invalid\rAn instance without \u0026#39;address\u0026#39; property is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42 } Invalid\rAn instance with more than 2 properties is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42, \u0026#34;address\u0026#34;: \u0026#34;some address\u0026#34; } It is important to note that one should be cautious when using the required and maxProperties keywords together in a schema because it can create a situation where the instance will always fail the validation, as shown in the above example. Schema with \u0026#39;maxProperties\u0026#39; and \u0026#39;minProperties\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;maxProperties\u0026#34;: 2, \u0026#34;minProperties\u0026#34;: 4 } Invalid\rAll object instances are invalid against the above schema\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42 } Valid\rAny instance with a value other than an object is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 42 } When using maxProperties and minProperties together in a schema to add extra constraints on the instance, one must make sure that the value of minProperties is not greater than maxProperties; otherwise, no object instance will be valid against that schema. ","permalink":"http://localhost:1313/2020-12/validation/maxproperties/","tags":["assertion"],"title":"maxProperties"},{"contents":"The minContains keyword is used in conjunction with the contains keyword to specify the minimum number of items in an array instance that must validate against the contains subschema.\nThis keyword applies only to arrays. The value of this keyword must be a non-negative integer. If contains is not present within the same schema object, then this keyword has no effect. Examples Schema with the \u0026#39;minContains\u0026#39; and \u0026#39;contains\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;minContains\u0026#34;: 2 } Valid\rAn array instance with 2 or more items successfully validating against the \u0026#39;contains\u0026#39; subschema is valid\rInstance\r[ \u0026#34;Car\u0026#34;, \u0026#34;Bus\u0026#34;, 1, 2, \u0026#34;Bike\u0026#34; ] Invalid\rAn array instance with less than 2 items successfully validating against the \u0026#39;contains\u0026#39; subschema is invalid\rInstance\r[ \u0026#34;Car\u0026#34;, 1 ] Invalid\rAn empty array is invalid\rInstance\r[] Schema with the \u0026#39;minContains\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;minContains\u0026#34;: 2 } // If contains is not present, \u0026#39;minContains\u0026#39; has no effect on validation. Valid\rAn array instance with any items is valid\rInstance\r[ \u0026#34;John\u0026#34;, false, 29, { \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; }, [ 5, 7 ] ] Valid\rAn empty array is also valid\rInstance\r[] Schema with the \u0026#39;minContains\u0026#39; and \u0026#39;contains\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;minContains\u0026#34;: 0 } Valid\rAn array instance with any items is valid\rInstance\r[ \u0026#34;John\u0026#34;, false, 29, { \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; }, [ 5, 7 ] ] Valid\rAn empty array is also valid\rInstance\r[] It is important to note that the contains keyword requires at least one item of the array instance to validate against its subschema. However, when minContains is set to 0, the schema would behave as if it does not have the contains keyword, as shown in the above example. ","permalink":"http://localhost:1313/2020-12/validation/mincontains/","tags":["assertion"],"title":"minContains"},{"contents":"The minimum keyword is used to set the lower limit on numeric instances. It specifies that the numeric value being validated must be greater than or equal to the provided minimum value.\nValidation succeeds if the number is greater than or equal to the specified minimum. Examples Schema defining the lower limit of 6 on numeric values\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;minimum\u0026#34;: 6 } Valid\rAn instance with a numeric value greater than 6 is valid\rInstance\r8.1 Invalid\rAn instance with a numeric value less than 6 is invalid\rInstance\r4 Valid\rAn instance with a numeric value equal to 6 is valid\rInstance\r6 Schema allowing either a null value or a numeric value with a lower limit of 10.99\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;null\u0026#34;, \u0026#34;number\u0026#34; ], \u0026#34;minimum\u0026#34;: 10.99 } Valid\rAn instance with a numeric value greater than or equal to 10.99 is valid\rInstance\r15 Invalid\rAn instance with a string datatype is invalid\rInstance\r\u0026#34;Hello World!\u0026#34; Valid\rAn instance with a null value is valid\rInstance\rnull ","permalink":"http://localhost:1313/2020-12/validation/minimum/","tags":["assertion"],"title":"minimum"},{"contents":"The minItems keyword specifies the minimum number of items that must be present in an array. It can be used to define constraints on the size of an array, ensuring that it contains at least a certain number of elements.\nAn array is valid if it has at least the specified number of elements. Examples Schema with \u0026#39;minItems\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;minItems\u0026#34;: 3 } Valid\rAn array instance with 3 or more elements is valid\rInstance\r[ 1, true, \u0026#34;hello\u0026#34; ] Invalid\rAn array instance with less than 3 elements is invalid\rInstance\r[ 1, \u0026#34;apple\u0026#34; ] Schema with the \u0026#39;minItems\u0026#39; and \u0026#39;items\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;minItems\u0026#34;: 2 } Valid\rAn array instance containing 2 or more items, which conform to the \u0026#39;items\u0026#39; subschema, is valid\rInstance\r[ false, false, true ] Invalid\rAn array instance with less than 2 elements is invalid\rInstance\r[ false ] Schema with the \u0026#39;minItems\u0026#39;, \u0026#39;prefixItems\u0026#39; and \u0026#39;contains\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;prefixItems\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; }, { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } ], \u0026#34;contains\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;boolean\u0026#34; }, \u0026#34;minItems\u0026#34;: 3 } Valid\rAn array instance containing 3 or more items, which successfully validates against \u0026#39;prefixItems\u0026#39; and \u0026#39;contains\u0026#39;, is valid\rInstance\r[ 1, \u0026#34;John\u0026#34;, false ] Invalid\rAn array instance with less than 3 elements is invalid\rInstance\r[ 1, \u0026#34;John\u0026#34; ] Invalid\rFirst and second items should be number and string respectively\rInstance\r[ \u0026#34;John\u0026#34;, 1, false ] ","permalink":"http://localhost:1313/2020-12/validation/minitems/","tags":["assertion"],"title":"minItems"},{"contents":"The minLength keyword is used to specify the minimum length of a string instance. It defines the minimum number of characters that a valid string must have to satisfy the schema.\nString length is counted in characters, not bytes. Validation succeeds if the string length is greater than or equal to the specified minLength. Examples Schema requiring minimum string length of 5\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;minLength\u0026#34;: 5 } Valid\rAn instance with a string length greater than or equal to 5 is valid\rInstance\r\u0026#34;This is a valid string\u0026#34; Invalid\rAn instance with a string length less than 5 is invalid\rInstance\r\u0026#34;foo\u0026#34; Schema which allows either a string with at least 3 characters or a numeric value\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;string\u0026#34;, \u0026#34;number\u0026#34; ], \u0026#34;minLength\u0026#34;: 3 } Valid\rAn instance with a string length greater than or equal to 3 is valid\rInstance\r\u0026#34;foo\u0026#34; Invalid\rAn instance with a string length less than 3 is valid\rInstance\r\u0026#34;hi\u0026#34; Valid\rAn instance with a numeric value is valid\rInstance\r55 ","permalink":"http://localhost:1313/2020-12/validation/minlength/","tags":["assertion"],"title":"minLength"},{"contents":"The minProperties keyword is used to specify the inclusive minimum number of properties allowed in an object instnace. If the number of properties in the object is less than the value specified by minProperties, the validation fails.\nExamples Schema with \u0026#39;minProperties\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;minProperties\u0026#34;: 1 } Valid\rAn instance with 1 or more properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: 3, \u0026#34;bar\u0026#34;: \u0026#34;hi\u0026#34; } Invalid\rAn empty instance is invalid\rInstance\r{} Valid\r\u0026#39;minProperties\u0026#39; has no effect on values other than objects\rInstance\rfalse Schema with \u0026#39;minProperties\u0026#39; and \u0026#39;properties\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;minProperties\u0026#34;: 2 } Valid\rAn instance with 2 or more properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 2 } Invalid\rAn instance with less than 2 properties is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } Schema with \u0026#39;minProperties\u0026#39;, \u0026#39;patternProperties\u0026#39; and \u0026#39;additionalProperties\u0026#39; keywords\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;patternProperties\u0026#34;: { \u0026#34;^[Aa]ge$\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } }, \u0026#34;additionalProperties\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;minProperties\u0026#34;: 2 } Valid\rAn instance with 2 or more properties is valid\rInstance\r{ \u0026#34;Age\u0026#34;: 22, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } Invalid\rAn instance with less than 2 properties is invalid\rInstance\r{ \u0026#34;Age\u0026#34;: 67 } Valid\rAn instance with additional properties conforming to the \u0026#39;additionalProperties\u0026#39; schema is valid\rInstance\r{ \u0026#34;myAge\u0026#34;: \u0026#34;22\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } Invalid\rAn instance with additional properties not conforming to the \u0026#39;additionalProperties\u0026#39; schema is invalid\rInstance\r{ \u0026#34;myAge\u0026#34;: 22, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } ","permalink":"http://localhost:1313/2020-12/validation/minproperties/","tags":["assertion"],"title":"minProperties"},{"contents":"The multipleOf keyword is used to specify that an instance must be a multiple of a given number. The value of this keyword must be strictly greater than zero.\nValidates if an instance is divisible by the specified number. Examples Schema with \u0026#39;multipleOf\u0026#39; set to an integer\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;multipleOf\u0026#34;: 5 } Valid\rA numeric instance that is a multiple of 5 is valid\rInstance\r10 Invalid\rA numeric instance that is not a multiple of 5 is invalid.\rInstance\r8 Valid\r-15 is a multiple of 5\rInstance\r-15 Valid\rAn instance with a string value is valid\rInstance\r\u0026#34;foo\u0026#34; multipleOf only affects numeric instances and has no effect on other types of instances. Schema with \u0026#39;multipleOf\u0026#39; set to a real number\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34;, \u0026#34;multipleOf\u0026#34;: 4.1 } Valid\rA numeric instance that is a multiple of 4.1 is valid\rInstance\r8.2 Invalid\r2 is not a multiple of 4.1\rInstance\r2 Valid\r0 is a multiple of 4.1\rInstance\r0 Invalid\rAn instance with a string value is invalid\rInstance\r\u0026#34;foo\u0026#34; multipleOf only affects numeric instances and has no effect on other types of instances. However, the above instance failed due to the type constraint. ","permalink":"http://localhost:1313/2020-12/validation/multipleof/","tags":["assertion"],"title":"multipleOf"},{"contents":"The pattern keyword in JSON Schema is designed to define a regular expression pattern that a string value within an instance must adhere to. This regular expression is specified as a string for the pattern keyword. It functions as follows:\nA string value is considered valid only if it successfully matches the specified pattern. The regular expressions used with pattern are not implicitly anchored, requiring a complete match for validation. Partial matches are not accepted. Examples Schema with regular expression for email validation\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\\\.[a-zA-Z]{2,}$\u0026#34; } Valid\rAn instance adhering to the regular expression is valid\rInstance\r\u0026#34;john.doe@example.com\u0026#34; Invalid\rAn instance not adhering to the regular expression is invalid\rInstance\r\u0026#34;invalid@yahoo\u0026#34; Schema with regular expression for password rules\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;^(?=.*[a-z])(?=.*[A-Z])(?=.*\\\\d)[a-zA-Z\\\\d]{8,}$\u0026#34; } Valid\rAn instance adhering to the regular expression is valid\rInstance\r\u0026#34;MyStrongPass89\u0026#34; Invalid\rAn instance not adhering to the regular expression is invalid\rInstance\r\u0026#34;password\u0026#34; Schema with regular expression for usernames, including length restrictions\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;^[a-zA-Z0-9_]+$\u0026#34;, \u0026#34;minLength\u0026#34;: 5, \u0026#34;maxLength\u0026#34;: 15 } Valid\rAn instance with alphanumeric and underscore values, with a length between 5 and 15, is valid\rInstance\r\u0026#34;foo_bar123\u0026#34; Invalid\rAn instance with special character in invalid\rInstance\r\u0026#34;invalid#username\u0026#34; Invalid\rAn instance that matches the regex but goes out of bounds is invalid\rInstance\r\u0026#34;username_toolong123\u0026#34; This keyword can be combined with other string-related keywords, such as maxLength and minLength, for comprehensive validation. Schema with regular expression for some specific pattern\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;apple\u0026#34; } Valid\rAn instance matching the pattern is valid\rInstance\r\u0026#34;apple\u0026#34; Valid\rAn instance is also valid if the pattern matches anywhere within the string\rInstance\r\u0026#34;I love apples!\u0026#34; When defining regular expressions, it\u0026rsquo;s crucial to note that a string is considered valid if the expression matches anywhere within it, as demonstrated in the above example.\nTo avoid this and ensure that the entire string exactly matches the pattern, you would surround the regular expression with ^ and $. See the example below.\nSchema with a regular expression enforcing an exact pattern match\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34;, \u0026#34;pattern\u0026#34;: \u0026#34;^apple$\u0026#34; } Valid\rAn instance matching the pattern is valid\rInstance\r\u0026#34;apple\u0026#34; Invalid\rAn instance containing characters other than \u0026#34;apple\u0026#34; is invalid\rInstance\r\u0026#34;I love apples!\u0026#34; ","permalink":"http://localhost:1313/2020-12/validation/pattern/","tags":["assertion"],"title":"pattern"},{"contents":"The required keyword is used to specify which properties must be present within an object instance.\nExamples Schema with the \u0026#39;required\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;required\u0026#34;: [ \u0026#34;foo\u0026#34; ] } Valid\rAn instance with all the required properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: \u0026#34;bar\u0026#34; } Invalid\rAn instance with missing required properties is invalid\rInstance\r{ \u0026#34;bar\u0026#34;: false } Valid\rAn instance with all the required properties is valid\rInstance\r{ \u0026#34;foo\u0026#34;: [ \u0026#34;bar\u0026#34; ], \u0026#34;baz\u0026#34;: 13 } It is important to note that when the required properties are not defined in the properties, then the only requirement to make the instance valid is to have those properties present in the instance irrespective of their value\u0026rsquo;s datatype. Schema with the \u0026#39;required\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;age\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34; ] } Valid\rAn instance with all the required properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;age\u0026#34;: 65 } Invalid\rAn instance with missing required properties is invalid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;Doe\u0026#34; } Invalid\rThe value of \u0026#39;age\u0026#39; property must be an integer\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;age\u0026#34;: \u0026#34;48\u0026#34; } Schema with the \u0026#39;required\u0026#39; keyword in nested subschemas\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;address\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;city\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; }, \u0026#34;country\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;city\u0026#34;, \u0026#34;country\u0026#34; ] } }, \u0026#34;required\u0026#34;: [ \u0026#34;address\u0026#34; ] } Valid\rAn instance with all the required properties is valid\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;New York\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;USA\u0026#34; } } Invalid\r\u0026#39;name\u0026#39; property is missing in the root object\rInstance\r{ \u0026#34;address\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;Hyderabad\u0026#34;, \u0026#34;country\u0026#34;: \u0026#34;India\u0026#34; } } Invalid\r\u0026#39;country\u0026#39; property is missing in the nested object\rInstance\r{ \u0026#34;name\u0026#34;: \u0026#34;Doe\u0026#34;, \u0026#34;address\u0026#34;: { \u0026#34;city\u0026#34;: \u0026#34;Dallas\u0026#34; } } Schema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;name\u0026#34;, \u0026#34;age\u0026#34;, \u0026#34;name\u0026#34; ] } // Schema with duplicate items in the required list is invalid. ","permalink":"http://localhost:1313/2020-12/validation/required/","tags":["assertion"],"title":"required"},{"contents":"The supported types are as follows:\nType Description \u0026quot;null\u0026quot; The JSON null constant \u0026quot;boolean\u0026quot; The JSON true or false constants \u0026quot;object\u0026quot; A JSON object \u0026quot;array\u0026quot; A JSON array \u0026quot;number\u0026quot; A JSON number \u0026quot;integer\u0026quot; A JSON number that represents an integer \u0026quot;string\u0026quot; A JSON string Note that the JSON grammar does not distinguish between integer and real numbers. Still, JSON Schema provides the integer logical type.\nExamples A schema that describes numeric instances\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;number\u0026#34; } Valid\rAn integer is valid\rInstance\r42 Valid\rA real number is valid\rInstance\r3.14 Invalid\rA string is not valid\rInstance\r\u0026#34;foo\u0026#34; A schema that describes boolean or array instances\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: [ \u0026#34;boolean\u0026#34;, \u0026#34;array\u0026#34; ] } Valid\rThe true boolean is valid\rInstance\rtrue Invalid\rA number is invalid\rInstance\r1234 Valid\rAn arbitrary array is valid\rInstance\r[ 1, 2, 3 ] ","permalink":"http://localhost:1313/2020-12/validation/type/","tags":["assertion"],"title":"type"},{"contents":"The uniqueItems keyword is used to ensure that all the items in an array are unique. This keyword is particularly useful when you need to enforce that an array contains no duplicate elements.\nThis keyword, when set to true, specifies that all elements in an array must be unique. Examples Schema with \u0026#39;uniqueItems\u0026#39; property set to true\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;uniqueItems\u0026#34;: true } Valid\rAn array instance with unique elements is valid\rInstance\r[ 1, \u0026#34;hello\u0026#34;, true ] Invalid\rAn instance with duplicate elements is invalid\rInstance\r[ false, \u0026#34;world\u0026#34;, 2, 2 ] Invalid\rAn instance with duplicate complex structures (objects) is invalid\rInstance\r[ { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; }, false, \u0026#34;world\u0026#34;, 2, { \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; } ] Element uniqueness also deeply applies for complex structures like objects. Schema without the \u0026#39;uniqueItems\u0026#39; property or with \u0026#39;uniqueItems\u0026#39; property set to false\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34; } // or { \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;uniqueItems\u0026#34;: false } Valid\rAn array instance with unique elements is valid\rInstance\r[ 1, \u0026#34;hello\u0026#34;, true ] Valid\rAn array instance with duplicate elements is also valid\rInstance\r[ false, \u0026#34;world\u0026#34;, 2, 2 ] uniqueItems can be used with other array keywords like items and prefixItems to add more constraints to the instance. See the example below. Schema with \u0026#39;uniqueItems\u0026#39; and \u0026#39;items\u0026#39; keyword\rSchema\r{ \u0026#34;$schema\u0026#34;: \u0026#34;https://json-schema.org/draft/2020-12/schema\u0026#34;, \u0026#34;type\u0026#34;: \u0026#34;array\u0026#34;, \u0026#34;items\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;object\u0026#34;, \u0026#34;properties\u0026#34;: { \u0026#34;id\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;integer\u0026#34; }, \u0026#34;name\u0026#34;: { \u0026#34;type\u0026#34;: \u0026#34;string\u0026#34; } }, \u0026#34;required\u0026#34;: [ \u0026#34;id\u0026#34;, \u0026#34;name\u0026#34; ] }, \u0026#34;uniqueItems\u0026#34;: true } Valid\rAn array instance with unique objects is valid\rInstance\r[ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;John\u0026#34; }, { \u0026#34;id\u0026#34;: 2, \u0026#34;name\u0026#34;: \u0026#34;Doe\u0026#34; } ] Invalid\rAn instance with duplicate objects is invalid\rInstance\r[ { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Jane\u0026#34; }, { \u0026#34;id\u0026#34;: 1, \u0026#34;name\u0026#34;: \u0026#34;Jane\u0026#34; } ] ","permalink":"http://localhost:1313/2020-12/validation/uniqueitems/","tags":["assertion"],"title":"uniqueItems"}]